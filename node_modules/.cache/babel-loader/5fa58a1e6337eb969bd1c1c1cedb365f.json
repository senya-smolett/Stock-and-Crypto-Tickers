{"ast":null,"code":"'use strict';\n\nconst {\n  ROUND_UP,\n  ROUND_DOWN\n} = require('./number');\n\nconst {\n  NotSupported\n} = require('../errors'); //-------------------------------------------------------------------------\n// converts timeframe to seconds\n\n\nconst parseTimeframe = timeframe => {\n  const amount = timeframe.slice(0, -1);\n  const unit = timeframe.slice(-1);\n  let scale = undefined;\n\n  if (unit === 'y') {\n    scale = 60 * 60 * 24 * 365;\n  } else if (unit === 'M') {\n    scale = 60 * 60 * 24 * 30;\n  } else if (unit === 'w') {\n    scale = 60 * 60 * 24 * 7;\n  } else if (unit === 'd') {\n    scale = 60 * 60 * 24;\n  } else if (unit === 'h') {\n    scale = 60 * 60;\n  } else if (unit === 'm') {\n    scale = 60;\n  } else if (unit === 's') {\n    scale = 1;\n  } else {\n    throw new NotSupported('timeframe unit ' + unit + ' is not supported');\n  }\n\n  return amount * scale;\n};\n\nconst roundTimeframe = (timeframe, timestamp, direction = ROUND_DOWN) => {\n  const ms = parseTimeframe(timeframe) * 1000; // Get offset based on timeframe in milliseconds\n\n  const offset = timestamp % ms;\n  return timestamp - offset + (direction === ROUND_UP ? ms : 0);\n}; // given a sorted arrays of trades (recent last) and a timeframe builds an array of OHLCV candles\n\n\nconst buildOHLCVC = (trades, timeframe = '1m', since = -Infinity, limit = Infinity) => {\n  const ms = parseTimeframe(timeframe) * 1000;\n  const ohlcvs = [];\n  const [timestamp,,\n  /* open */\n  high, low, close, volume, count] = [0, 1, 2, 3, 4, 5, 6];\n  const oldest = Math.min(trades.length - 1, limit);\n\n  for (let i = 0; i <= oldest; i++) {\n    const trade = trades[i];\n\n    if (trade.timestamp < since) {\n      continue;\n    }\n\n    const openingTime = Math.floor(trade.timestamp / ms) * ms; // shift to the edge of m/h/d (but not M)\n\n    const candle = ohlcvs.length - 1;\n\n    if (candle === -1 || openingTime >= ohlcvs[candle][timestamp] + ms) {\n      // moved to a new timeframe -> create a new candle from opening trade\n      ohlcvs.push([openingTime, // timestamp\n      trade.price, // O\n      trade.price, // H\n      trade.price, // L\n      trade.price, // C\n      trade.amount, // V\n      1 // count\n      ]);\n    } else {\n      // still processing the same timeframe -> update opening trade\n      ohlcvs[candle][high] = Math.max(ohlcvs[candle][high], trade.price);\n      ohlcvs[candle][low] = Math.min(ohlcvs[candle][low], trade.price);\n      ohlcvs[candle][close] = trade.price;\n      ohlcvs[candle][volume] += trade.amount;\n      ohlcvs[candle][count]++;\n    } // if\n\n  } // for\n\n\n  return ohlcvs;\n};\n\nconst extractParams = string => {\n  const re = /{([\\w-]+)}/g;\n  const matches = [];\n  let match = re.exec(string);\n\n  while (match) {\n    matches.push(match[1]);\n    match = re.exec(string);\n  }\n\n  return matches;\n};\n\nconst implodeParams = (string, params) => {\n  if (!Array.isArray(params)) {\n    const keys = Object.keys(params);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n\n      if (!Array.isArray(params[key])) {\n        string = string.replace('{' + key + '}', params[key]);\n      }\n    }\n  }\n\n  return string;\n};\n\nfunction vwap(baseVolume, quoteVolume) {\n  return baseVolume !== undefined && quoteVolume !== undefined && baseVolume > 0 ? quoteVolume / baseVolume : undefined;\n}\n/*  ------------------------------------------------------------------------ */\n\n\nmodule.exports = {\n  aggregate(bidasks) {\n    const result = {};\n\n    for (let i = 0; i < bidasks.length; i++) {\n      const [price, volume] = bidasks[i];\n\n      if (volume > 0) {\n        result[price] = (result[price] || 0) + volume;\n      }\n    }\n\n    return Object.keys(result).map(price => [parseFloat(price), parseFloat(result[price])]);\n  },\n\n  parseTimeframe,\n  roundTimeframe,\n  buildOHLCVC,\n  ROUND_UP,\n  ROUND_DOWN,\n  implodeParams,\n  extractParams,\n  vwap\n};\n/*  ------------------------------------------------------------------------ */","map":{"version":3,"sources":["C:/Users/senya/Documents/Coding/React Projects/react-stock-ticker/node_modules/ccxt/js/base/functions/misc.js"],"names":["ROUND_UP","ROUND_DOWN","require","NotSupported","parseTimeframe","timeframe","amount","slice","unit","scale","undefined","roundTimeframe","timestamp","direction","ms","offset","buildOHLCVC","trades","since","Infinity","limit","ohlcvs","high","low","close","volume","count","oldest","Math","min","length","i","trade","openingTime","floor","candle","push","price","max","extractParams","string","re","matches","match","exec","implodeParams","params","Array","isArray","keys","Object","key","replace","vwap","baseVolume","quoteVolume","module","exports","aggregate","bidasks","result","map","parseFloat"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { ROUND_UP, ROUND_DOWN } = require ('./number')\nconst { NotSupported } = require ('../errors')\n\n//-------------------------------------------------------------------------\n// converts timeframe to seconds\nconst parseTimeframe = (timeframe) => {\n\n    const amount = timeframe.slice (0, -1)\n    const unit = timeframe.slice (-1)\n    let scale = undefined;\n\n    if (unit === 'y') {\n        scale = 60 * 60 * 24 * 365\n    } else if (unit === 'M') {\n        scale = 60 * 60 * 24 * 30\n    } else if (unit === 'w') {\n        scale = 60 * 60 * 24 * 7\n    } else if (unit === 'd') {\n        scale = 60 * 60 * 24\n    } else if (unit === 'h') {\n        scale = 60 * 60\n    } else if (unit === 'm') {\n        scale = 60\n    } else if (unit === 's') {\n        scale = 1\n    } else {\n        throw new NotSupported ('timeframe unit ' + unit + ' is not supported')\n    }\n\n    return amount * scale\n}\n\nconst roundTimeframe = (timeframe, timestamp, direction = ROUND_DOWN) => {\n    const ms = parseTimeframe (timeframe) * 1000\n    // Get offset based on timeframe in milliseconds\n    const offset = timestamp % ms\n    return timestamp - offset + ((direction === ROUND_UP) ? ms : 0);\n}\n\n// given a sorted arrays of trades (recent last) and a timeframe builds an array of OHLCV candles\nconst buildOHLCVC = (trades, timeframe = '1m', since = -Infinity, limit = Infinity) => {\n    const ms = parseTimeframe (timeframe) * 1000;\n    const ohlcvs = [];\n    const [ timestamp, /* open */, high, low, close, volume, count ] = [ 0, 1, 2, 3, 4, 5, 6 ];\n    const oldest = Math.min (trades.length - 1, limit);\n\n    for (let i = 0; i <= oldest; i++) {\n        const trade = trades[i];\n        if (trade.timestamp < since) {\n            continue;\n        }\n        const openingTime = Math.floor (trade.timestamp / ms) * ms; // shift to the edge of m/h/d (but not M)\n        const candle = ohlcvs.length - 1;\n\n        if (candle === -1 || openingTime >= ohlcvs[candle][timestamp] + ms) {\n            // moved to a new timeframe -> create a new candle from opening trade\n            ohlcvs.push ([\n                openingTime,  // timestamp\n                trade.price,  // O\n                trade.price,  // H\n                trade.price,  // L\n                trade.price,  // C\n                trade.amount, // V\n                1,            // count\n            ]);\n        } else {\n            // still processing the same timeframe -> update opening trade\n            ohlcvs[candle][high] = Math.max (ohlcvs[candle][high], trade.price);\n            ohlcvs[candle][low] = Math.min (ohlcvs[candle][low], trade.price);\n            ohlcvs[candle][close] = trade.price;\n            ohlcvs[candle][volume] += trade.amount;\n            ohlcvs[candle][count]++;\n        } // if\n    } // for\n    return ohlcvs;\n}\n\nconst extractParams = (string) => {\n    const re = /{([\\w-]+)}/g\n    const matches = []\n    let match = re.exec (string)\n    while (match) {\n        matches.push (match[1])\n        match = re.exec (string)\n    }\n    return matches\n}\n\nconst implodeParams = (string, params) => {\n    if (!Array.isArray (params)) {\n        const keys = Object.keys (params)\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i]\n            if (!Array.isArray (params[key])) {\n                string = string.replace ('{' + key + '}', params[key])\n            }\n        }\n    }\n    return string\n}\n\nfunction vwap (baseVolume, quoteVolume) {\n    return ((baseVolume !== undefined) && (quoteVolume !== undefined) && (baseVolume > 0)) ? (quoteVolume / baseVolume) : undefined\n}\n\n/*  ------------------------------------------------------------------------ */\n\nmodule.exports = {\n\n    aggregate (bidasks) {\n\n        const result = {}\n\n        for (let i = 0; i < bidasks.length; i++) {\n            const [ price, volume ] = bidasks[i];\n            if (volume > 0) {\n                result[price] = (result[price] || 0) + volume\n            }\n        }\n\n        return Object.keys (result).map ((price) => [parseFloat (price), parseFloat (result[price])])\n    },\n\n    parseTimeframe,\n    roundTimeframe,\n    buildOHLCVC,\n    ROUND_UP,\n    ROUND_DOWN,\n\n    implodeParams,\n    extractParams,\n\n    vwap,\n}\n\n/*  ------------------------------------------------------------------------ */\n"]},"metadata":{},"sourceType":"script"}