{"ast":null,"code":"'use strict'; //  ---------------------------------------------------------------------------\n\nconst Exchange = require('./base/Exchange');\n\nconst {\n  ExchangeError,\n  InsufficientFunds,\n  InvalidOrder,\n  AuthenticationError,\n  PermissionDenied,\n  InvalidNonce,\n  OrderNotFound,\n  DDoSProtection\n} = require('./base/errors'); //  ---------------------------------------------------------------------------\n\n\nmodule.exports = class btcbox extends Exchange {\n  describe() {\n    return this.deepExtend(super.describe(), {\n      'id': 'btcbox',\n      'name': 'BtcBox',\n      'countries': ['JP'],\n      'rateLimit': 1000,\n      'version': 'v1',\n      'has': {\n        'cancelOrder': true,\n        'CORS': false,\n        'createOrder': true,\n        'fetchBalance': true,\n        'fetchOpenOrders': true,\n        'fetchOrder': true,\n        'fetchOrderBook': true,\n        'fetchOrders': true,\n        'fetchTicker': true,\n        'fetchTickers': false,\n        'fetchTrades': true\n      },\n      'urls': {\n        'logo': 'https://user-images.githubusercontent.com/51840849/87327317-98c55400-c53c-11ea-9a11-81f7d951cc74.jpg',\n        'api': 'https://www.btcbox.co.jp/api',\n        'www': 'https://www.btcbox.co.jp/',\n        'doc': 'https://blog.btcbox.jp/en/archives/8762',\n        'fees': 'https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction'\n      },\n      'api': {\n        'public': {\n          'get': ['depth', 'orders', 'ticker']\n        },\n        'private': {\n          'post': ['balance', 'trade_add', 'trade_cancel', 'trade_list', 'trade_view', 'wallet']\n        }\n      },\n      'markets': {\n        'BTC/JPY': {\n          'id': 'btc',\n          'symbol': 'BTC/JPY',\n          'base': 'BTC',\n          'quote': 'JPY',\n          'baseId': 'btc',\n          'quoteId': 'jpy',\n          'taker': 0.05 / 100,\n          'maker': 0.05 / 100\n        },\n        'ETH/JPY': {\n          'id': 'eth',\n          'symbol': 'ETH/JPY',\n          'base': 'ETH',\n          'quote': 'JPY',\n          'baseId': 'eth',\n          'quoteId': 'jpy',\n          'taker': 0.10 / 100,\n          'maker': 0.10 / 100\n        },\n        'LTC/JPY': {\n          'id': 'ltc',\n          'symbol': 'LTC/JPY',\n          'base': 'LTC',\n          'quote': 'JPY',\n          'baseId': 'ltc',\n          'quoteId': 'jpy',\n          'taker': 0.10 / 100,\n          'maker': 0.10 / 100\n        },\n        'BCH/JPY': {\n          'id': 'bch',\n          'symbol': 'BCH/JPY',\n          'base': 'BCH',\n          'quote': 'JPY',\n          'baseId': 'bch',\n          'quoteId': 'jpy',\n          'taker': 0.10 / 100,\n          'maker': 0.10 / 100\n        }\n      },\n      'exceptions': {\n        '104': AuthenticationError,\n        '105': PermissionDenied,\n        '106': InvalidNonce,\n        '107': InvalidOrder,\n        // price should be an integer\n        '200': InsufficientFunds,\n        '201': InvalidOrder,\n        // amount too small\n        '202': InvalidOrder,\n        // price should be [0 : 1000000]\n        '203': OrderNotFound,\n        '401': OrderNotFound,\n        // cancel canceled, closed or non-existent order\n        '402': DDoSProtection\n      }\n    });\n  }\n\n  async fetchBalance(params = {}) {\n    await this.loadMarkets();\n    const response = await this.privatePostBalance(params);\n    const result = {\n      'info': response\n    };\n    const codes = Object.keys(this.currencies);\n\n    for (let i = 0; i < codes.length; i++) {\n      const code = codes[i];\n      const currency = this.currency(code);\n      const currencyId = currency['id'];\n      const free = currencyId + '_balance';\n\n      if (free in response) {\n        const account = this.account();\n        const used = currencyId + '_lock';\n        account['free'] = this.safeFloat(response, free);\n        account['used'] = this.safeFloat(response, used);\n        result[code] = account;\n      }\n    }\n\n    return this.parseBalance(result);\n  }\n\n  async fetchOrderBook(symbol, limit = undefined, params = {}) {\n    await this.loadMarkets();\n    const market = this.market(symbol);\n    const request = {};\n    const numSymbols = this.symbols.length;\n\n    if (numSymbols > 1) {\n      request['coin'] = market['baseId'];\n    }\n\n    const response = await this.publicGetDepth(this.extend(request, params));\n    return this.parseOrderBook(response);\n  }\n\n  parseTicker(ticker, market = undefined) {\n    const timestamp = this.milliseconds();\n    let symbol = undefined;\n\n    if (market !== undefined) {\n      symbol = market['symbol'];\n    }\n\n    const last = this.safeFloat(ticker, 'last');\n    return {\n      'symbol': symbol,\n      'timestamp': timestamp,\n      'datetime': this.iso8601(timestamp),\n      'high': this.safeFloat(ticker, 'high'),\n      'low': this.safeFloat(ticker, 'low'),\n      'bid': this.safeFloat(ticker, 'buy'),\n      'bidVolume': undefined,\n      'ask': this.safeFloat(ticker, 'sell'),\n      'askVolume': undefined,\n      'vwap': undefined,\n      'open': undefined,\n      'close': last,\n      'last': last,\n      'previousClose': undefined,\n      'change': undefined,\n      'percentage': undefined,\n      'average': undefined,\n      'baseVolume': this.safeFloat(ticker, 'vol'),\n      'quoteVolume': this.safeFloat(ticker, 'volume'),\n      'info': ticker\n    };\n  }\n\n  async fetchTicker(symbol, params = {}) {\n    await this.loadMarkets();\n    const market = this.market(symbol);\n    const request = {};\n    const numSymbols = this.symbols.length;\n\n    if (numSymbols > 1) {\n      request['coin'] = market['baseId'];\n    }\n\n    const response = await this.publicGetTicker(this.extend(request, params));\n    return this.parseTicker(response, market);\n  }\n\n  parseTrade(trade, market = undefined) {\n    const timestamp = this.safeTimestamp(trade, 'date');\n    let symbol = undefined;\n\n    if (market !== undefined) {\n      symbol = market['symbol'];\n    }\n\n    const id = this.safeString(trade, 'tid');\n    const price = this.safeFloat(trade, 'price');\n    const amount = this.safeFloat(trade, 'amount');\n    let cost = undefined;\n\n    if (amount !== undefined) {\n      if (price !== undefined) {\n        cost = price * amount;\n      }\n    }\n\n    const type = undefined;\n    const side = this.safeString(trade, 'type');\n    return {\n      'info': trade,\n      'id': id,\n      'order': undefined,\n      'timestamp': timestamp,\n      'datetime': this.iso8601(timestamp),\n      'symbol': symbol,\n      'type': type,\n      'side': side,\n      'takerOrMaker': undefined,\n      'price': price,\n      'amount': amount,\n      'cost': cost,\n      'fee': undefined\n    };\n  }\n\n  async fetchTrades(symbol, since = undefined, limit = undefined, params = {}) {\n    await this.loadMarkets();\n    const market = this.market(symbol);\n    const request = {};\n    const numSymbols = this.symbols.length;\n\n    if (numSymbols > 1) {\n      request['coin'] = market['baseId'];\n    }\n\n    const response = await this.publicGetOrders(this.extend(request, params));\n    return this.parseTrades(response, market, since, limit);\n  }\n\n  async createOrder(symbol, type, side, amount, price = undefined, params = {}) {\n    await this.loadMarkets();\n    const market = this.market(symbol);\n    const request = {\n      'amount': amount,\n      'price': price,\n      'type': side,\n      'coin': market['baseId']\n    };\n    const response = await this.privatePostTradeAdd(this.extend(request, params)); //\n    //     {\n    //         \"result\":true,\n    //         \"id\":\"11\"\n    //     }\n    //\n\n    return this.parseOrder(response, market);\n  }\n\n  async cancelOrder(id, symbol = undefined, params = {}) {\n    await this.loadMarkets(); // a special case for btcbox â€“ default symbol is BTC/JPY\n\n    if (symbol === undefined) {\n      symbol = 'BTC/JPY';\n    }\n\n    const market = this.market(symbol);\n    const request = {\n      'id': id,\n      'coin': market['baseId']\n    };\n    const response = await this.privatePostTradeCancel(this.extend(request, params)); //\n    //     {\"result\":true, \"id\":\"11\"}\n    //\n\n    return this.parseOrder(response, market);\n  }\n\n  parseOrderStatus(status) {\n    const statuses = {\n      // TODO: complete list\n      'part': 'open',\n      // partially or not at all executed\n      'all': 'closed',\n      // fully executed\n      'cancelled': 'canceled',\n      'closed': 'closed',\n      // never encountered, seems to be bug in the doc\n      'no': 'closed' // not clarified in the docs...\n\n    };\n    return this.safeString(statuses, status, status);\n  }\n\n  parseOrder(order, market = undefined) {\n    //\n    //     {\n    //         \"id\":11,\n    //         \"datetime\":\"2014-10-21 10:47:20\",\n    //         \"type\":\"sell\",\n    //         \"price\":42000,\n    //         \"amount_original\":1.2,\n    //         \"amount_outstanding\":1.2,\n    //         \"status\":\"closed\",\n    //         \"trades\":[]\n    //     }\n    //\n    const id = this.safeString(order, 'id');\n    const datetimeString = this.safeString(order, 'datetime');\n    let timestamp = undefined;\n\n    if (datetimeString !== undefined) {\n      timestamp = this.parse8601(order['datetime'] + '+09:00'); // Tokyo time\n    }\n\n    const amount = this.safeFloat(order, 'amount_original');\n    const remaining = this.safeFloat(order, 'amount_outstanding');\n    let filled = undefined;\n\n    if (amount !== undefined) {\n      if (remaining !== undefined) {\n        filled = amount - remaining;\n      }\n    }\n\n    const price = this.safeFloat(order, 'price');\n    let cost = undefined;\n\n    if (price !== undefined) {\n      if (filled !== undefined) {\n        cost = filled * price;\n      }\n    } // status is set by fetchOrder method only\n\n\n    let status = this.parseOrderStatus(this.safeString(order, 'status')); // fetchOrders do not return status, use heuristic\n\n    if (status === undefined) {\n      if (remaining !== undefined && remaining === 0) {\n        status = 'closed';\n      }\n    }\n\n    const trades = undefined; // todo: this.parseTrades (order['trades']);\n\n    let symbol = undefined;\n\n    if (market !== undefined) {\n      symbol = market['symbol'];\n    }\n\n    const side = this.safeString(order, 'type');\n    return {\n      'id': id,\n      'clientOrderId': undefined,\n      'timestamp': timestamp,\n      'datetime': this.iso8601(timestamp),\n      'lastTradeTimestamp': undefined,\n      'amount': amount,\n      'remaining': remaining,\n      'filled': filled,\n      'side': side,\n      'type': undefined,\n      'timeInForce': undefined,\n      'postOnly': undefined,\n      'status': status,\n      'symbol': symbol,\n      'price': price,\n      'stopPrice': undefined,\n      'cost': cost,\n      'trades': trades,\n      'fee': undefined,\n      'info': order,\n      'average': undefined\n    };\n  }\n\n  async fetchOrder(id, symbol = undefined, params = {}) {\n    await this.loadMarkets(); // a special case for btcbox â€“ default symbol is BTC/JPY\n\n    if (symbol === undefined) {\n      symbol = 'BTC/JPY';\n    }\n\n    const market = this.market(symbol);\n    const request = this.extend({\n      'id': id,\n      'coin': market['baseId']\n    }, params);\n    const response = await this.privatePostTradeView(this.extend(request, params));\n    return this.parseOrder(response, market);\n  }\n\n  async fetchOrdersByType(type, symbol = undefined, since = undefined, limit = undefined, params = {}) {\n    await this.loadMarkets(); // a special case for btcbox â€“ default symbol is BTC/JPY\n\n    if (symbol === undefined) {\n      symbol = 'BTC/JPY';\n    }\n\n    const market = this.market(symbol);\n    const request = {\n      'type': type,\n      // 'open' or 'all'\n      'coin': market['baseId']\n    };\n    const response = await this.privatePostTradeList(this.extend(request, params));\n    const orders = this.parseOrders(response, market, since, limit); // status (open/closed/canceled) is undefined\n    // btcbox does not return status, but we know it's 'open' as we queried for open orders\n\n    if (type === 'open') {\n      for (let i = 0; i < orders.length; i++) {\n        orders[i]['status'] = 'open';\n      }\n    }\n\n    return orders;\n  }\n\n  async fetchOrders(symbol = undefined, since = undefined, limit = undefined, params = {}) {\n    return await this.fetchOrdersByType('all', symbol, since, limit, params);\n  }\n\n  async fetchOpenOrders(symbol = undefined, since = undefined, limit = undefined, params = {}) {\n    return await this.fetchOrdersByType('open', symbol, since, limit, params);\n  }\n\n  nonce() {\n    return this.milliseconds();\n  }\n\n  sign(path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {\n    let url = this.urls['api'] + '/' + this.version + '/' + path;\n\n    if (api === 'public') {\n      if (Object.keys(params).length) {\n        url += '?' + this.urlencode(params);\n      }\n    } else {\n      this.checkRequiredCredentials();\n      const nonce = this.nonce().toString();\n      const query = this.extend({\n        'key': this.apiKey,\n        'nonce': nonce\n      }, params);\n      const request = this.urlencode(query);\n      const secret = this.hash(this.encode(this.secret));\n      query['signature'] = this.hmac(this.encode(request), this.encode(secret));\n      body = this.urlencode(query);\n      headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      };\n    }\n\n    return {\n      'url': url,\n      'method': method,\n      'body': body,\n      'headers': headers\n    };\n  }\n\n  handleErrors(httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {\n    if (response === undefined) {\n      return; // resort to defaultErrorHandler\n    } // typical error response: {\"result\":false,\"code\":\"401\"}\n\n\n    if (httpCode >= 400) {\n      return; // resort to defaultErrorHandler\n    }\n\n    const result = this.safeValue(response, 'result');\n\n    if (result === undefined || result === true) {\n      return; // either public API (no error codes expected) or success\n    }\n\n    const code = this.safeValue(response, 'code');\n    const feedback = this.id + ' ' + body;\n    this.throwExactlyMatchedException(this.exceptions, code, feedback);\n    throw new ExchangeError(feedback); // unknown message\n  }\n\n  async request(path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {\n    let response = await this.fetch2(path, api, method, params, headers, body);\n\n    if (typeof response === 'string') {\n      // sometimes the exchange returns whitespace prepended to json\n      response = this.strip(response);\n\n      if (!this.isJsonEncodedObject(response)) {\n        throw new ExchangeError(this.id + ' ' + response);\n      }\n\n      response = JSON.parse(response);\n    }\n\n    return response;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/senya/Documents/Coding/React Projects/react-stock-ticker/node_modules/ccxt/js/btcbox.js"],"names":["Exchange","require","ExchangeError","InsufficientFunds","InvalidOrder","AuthenticationError","PermissionDenied","InvalidNonce","OrderNotFound","DDoSProtection","module","exports","btcbox","describe","deepExtend","fetchBalance","params","loadMarkets","response","privatePostBalance","result","codes","Object","keys","currencies","i","length","code","currency","currencyId","free","account","used","safeFloat","parseBalance","fetchOrderBook","symbol","limit","undefined","market","request","numSymbols","symbols","publicGetDepth","extend","parseOrderBook","parseTicker","ticker","timestamp","milliseconds","last","iso8601","fetchTicker","publicGetTicker","parseTrade","trade","safeTimestamp","id","safeString","price","amount","cost","type","side","fetchTrades","since","publicGetOrders","parseTrades","createOrder","privatePostTradeAdd","parseOrder","cancelOrder","privatePostTradeCancel","parseOrderStatus","status","statuses","order","datetimeString","parse8601","remaining","filled","trades","fetchOrder","privatePostTradeView","fetchOrdersByType","privatePostTradeList","orders","parseOrders","fetchOrders","fetchOpenOrders","nonce","sign","path","api","method","headers","body","url","urls","version","urlencode","checkRequiredCredentials","toString","query","apiKey","secret","hash","encode","hmac","handleErrors","httpCode","reason","requestHeaders","requestBody","safeValue","feedback","throwExactlyMatchedException","exceptions","fetch2","strip","isJsonEncodedObject","JSON","parse"],"mappings":"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","sourcesContent":["'use strict';\n\n//  ---------------------------------------------------------------------------\n\nconst Exchange = require ('./base/Exchange');\nconst { ExchangeError, InsufficientFunds, InvalidOrder, AuthenticationError, PermissionDenied, InvalidNonce, OrderNotFound, DDoSProtection } = require ('./base/errors');\n\n//  ---------------------------------------------------------------------------\n\nmodule.exports = class btcbox extends Exchange {\n    describe () {\n        return this.deepExtend (super.describe (), {\n            'id': 'btcbox',\n            'name': 'BtcBox',\n            'countries': [ 'JP' ],\n            'rateLimit': 1000,\n            'version': 'v1',\n            'has': {\n                'cancelOrder': true,\n                'CORS': false,\n                'createOrder': true,\n                'fetchBalance': true,\n                'fetchOpenOrders': true,\n                'fetchOrder': true,\n                'fetchOrderBook': true,\n                'fetchOrders': true,\n                'fetchTicker': true,\n                'fetchTickers': false,\n                'fetchTrades': true,\n            },\n            'urls': {\n                'logo': 'https://user-images.githubusercontent.com/51840849/87327317-98c55400-c53c-11ea-9a11-81f7d951cc74.jpg',\n                'api': 'https://www.btcbox.co.jp/api',\n                'www': 'https://www.btcbox.co.jp/',\n                'doc': 'https://blog.btcbox.jp/en/archives/8762',\n                'fees': 'https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction',\n            },\n            'api': {\n                'public': {\n                    'get': [\n                        'depth',\n                        'orders',\n                        'ticker',\n                    ],\n                },\n                'private': {\n                    'post': [\n                        'balance',\n                        'trade_add',\n                        'trade_cancel',\n                        'trade_list',\n                        'trade_view',\n                        'wallet',\n                    ],\n                },\n            },\n            'markets': {\n                'BTC/JPY': { 'id': 'btc', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY', 'baseId': 'btc', 'quoteId': 'jpy', 'taker': 0.05 / 100, 'maker': 0.05 / 100 },\n                'ETH/JPY': { 'id': 'eth', 'symbol': 'ETH/JPY', 'base': 'ETH', 'quote': 'JPY', 'baseId': 'eth', 'quoteId': 'jpy', 'taker': 0.10 / 100, 'maker': 0.10 / 100 },\n                'LTC/JPY': { 'id': 'ltc', 'symbol': 'LTC/JPY', 'base': 'LTC', 'quote': 'JPY', 'baseId': 'ltc', 'quoteId': 'jpy', 'taker': 0.10 / 100, 'maker': 0.10 / 100 },\n                'BCH/JPY': { 'id': 'bch', 'symbol': 'BCH/JPY', 'base': 'BCH', 'quote': 'JPY', 'baseId': 'bch', 'quoteId': 'jpy', 'taker': 0.10 / 100, 'maker': 0.10 / 100 },\n            },\n            'exceptions': {\n                '104': AuthenticationError,\n                '105': PermissionDenied,\n                '106': InvalidNonce,\n                '107': InvalidOrder, // price should be an integer\n                '200': InsufficientFunds,\n                '201': InvalidOrder, // amount too small\n                '202': InvalidOrder, // price should be [0 : 1000000]\n                '203': OrderNotFound,\n                '401': OrderNotFound, // cancel canceled, closed or non-existent order\n                '402': DDoSProtection,\n            },\n        });\n    }\n\n    async fetchBalance (params = {}) {\n        await this.loadMarkets ();\n        const response = await this.privatePostBalance (params);\n        const result = { 'info': response };\n        const codes = Object.keys (this.currencies);\n        for (let i = 0; i < codes.length; i++) {\n            const code = codes[i];\n            const currency = this.currency (code);\n            const currencyId = currency['id'];\n            const free = currencyId + '_balance';\n            if (free in response) {\n                const account = this.account ();\n                const used = currencyId + '_lock';\n                account['free'] = this.safeFloat (response, free);\n                account['used'] = this.safeFloat (response, used);\n                result[code] = account;\n            }\n        }\n        return this.parseBalance (result);\n    }\n\n    async fetchOrderBook (symbol, limit = undefined, params = {}) {\n        await this.loadMarkets ();\n        const market = this.market (symbol);\n        const request = {};\n        const numSymbols = this.symbols.length;\n        if (numSymbols > 1) {\n            request['coin'] = market['baseId'];\n        }\n        const response = await this.publicGetDepth (this.extend (request, params));\n        return this.parseOrderBook (response);\n    }\n\n    parseTicker (ticker, market = undefined) {\n        const timestamp = this.milliseconds ();\n        let symbol = undefined;\n        if (market !== undefined) {\n            symbol = market['symbol'];\n        }\n        const last = this.safeFloat (ticker, 'last');\n        return {\n            'symbol': symbol,\n            'timestamp': timestamp,\n            'datetime': this.iso8601 (timestamp),\n            'high': this.safeFloat (ticker, 'high'),\n            'low': this.safeFloat (ticker, 'low'),\n            'bid': this.safeFloat (ticker, 'buy'),\n            'bidVolume': undefined,\n            'ask': this.safeFloat (ticker, 'sell'),\n            'askVolume': undefined,\n            'vwap': undefined,\n            'open': undefined,\n            'close': last,\n            'last': last,\n            'previousClose': undefined,\n            'change': undefined,\n            'percentage': undefined,\n            'average': undefined,\n            'baseVolume': this.safeFloat (ticker, 'vol'),\n            'quoteVolume': this.safeFloat (ticker, 'volume'),\n            'info': ticker,\n        };\n    }\n\n    async fetchTicker (symbol, params = {}) {\n        await this.loadMarkets ();\n        const market = this.market (symbol);\n        const request = {};\n        const numSymbols = this.symbols.length;\n        if (numSymbols > 1) {\n            request['coin'] = market['baseId'];\n        }\n        const response = await this.publicGetTicker (this.extend (request, params));\n        return this.parseTicker (response, market);\n    }\n\n    parseTrade (trade, market = undefined) {\n        const timestamp = this.safeTimestamp (trade, 'date');\n        let symbol = undefined;\n        if (market !== undefined) {\n            symbol = market['symbol'];\n        }\n        const id = this.safeString (trade, 'tid');\n        const price = this.safeFloat (trade, 'price');\n        const amount = this.safeFloat (trade, 'amount');\n        let cost = undefined;\n        if (amount !== undefined) {\n            if (price !== undefined) {\n                cost = price * amount;\n            }\n        }\n        const type = undefined;\n        const side = this.safeString (trade, 'type');\n        return {\n            'info': trade,\n            'id': id,\n            'order': undefined,\n            'timestamp': timestamp,\n            'datetime': this.iso8601 (timestamp),\n            'symbol': symbol,\n            'type': type,\n            'side': side,\n            'takerOrMaker': undefined,\n            'price': price,\n            'amount': amount,\n            'cost': cost,\n            'fee': undefined,\n        };\n    }\n\n    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {\n        await this.loadMarkets ();\n        const market = this.market (symbol);\n        const request = {};\n        const numSymbols = this.symbols.length;\n        if (numSymbols > 1) {\n            request['coin'] = market['baseId'];\n        }\n        const response = await this.publicGetOrders (this.extend (request, params));\n        return this.parseTrades (response, market, since, limit);\n    }\n\n    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {\n        await this.loadMarkets ();\n        const market = this.market (symbol);\n        const request = {\n            'amount': amount,\n            'price': price,\n            'type': side,\n            'coin': market['baseId'],\n        };\n        const response = await this.privatePostTradeAdd (this.extend (request, params));\n        //\n        //     {\n        //         \"result\":true,\n        //         \"id\":\"11\"\n        //     }\n        //\n        return this.parseOrder (response, market);\n    }\n\n    async cancelOrder (id, symbol = undefined, params = {}) {\n        await this.loadMarkets ();\n        // a special case for btcbox â€“ default symbol is BTC/JPY\n        if (symbol === undefined) {\n            symbol = 'BTC/JPY';\n        }\n        const market = this.market (symbol);\n        const request = {\n            'id': id,\n            'coin': market['baseId'],\n        };\n        const response = await this.privatePostTradeCancel (this.extend (request, params));\n        //\n        //     {\"result\":true, \"id\":\"11\"}\n        //\n        return this.parseOrder (response, market);\n    }\n\n    parseOrderStatus (status) {\n        const statuses = {\n            // TODO: complete list\n            'part': 'open', // partially or not at all executed\n            'all': 'closed', // fully executed\n            'cancelled': 'canceled',\n            'closed': 'closed', // never encountered, seems to be bug in the doc\n            'no': 'closed', // not clarified in the docs...\n        };\n        return this.safeString (statuses, status, status);\n    }\n\n    parseOrder (order, market = undefined) {\n        //\n        //     {\n        //         \"id\":11,\n        //         \"datetime\":\"2014-10-21 10:47:20\",\n        //         \"type\":\"sell\",\n        //         \"price\":42000,\n        //         \"amount_original\":1.2,\n        //         \"amount_outstanding\":1.2,\n        //         \"status\":\"closed\",\n        //         \"trades\":[]\n        //     }\n        //\n        const id = this.safeString (order, 'id');\n        const datetimeString = this.safeString (order, 'datetime');\n        let timestamp = undefined;\n        if (datetimeString !== undefined) {\n            timestamp = this.parse8601 (order['datetime'] + '+09:00'); // Tokyo time\n        }\n        const amount = this.safeFloat (order, 'amount_original');\n        const remaining = this.safeFloat (order, 'amount_outstanding');\n        let filled = undefined;\n        if (amount !== undefined) {\n            if (remaining !== undefined) {\n                filled = amount - remaining;\n            }\n        }\n        const price = this.safeFloat (order, 'price');\n        let cost = undefined;\n        if (price !== undefined) {\n            if (filled !== undefined) {\n                cost = filled * price;\n            }\n        }\n        // status is set by fetchOrder method only\n        let status = this.parseOrderStatus (this.safeString (order, 'status'));\n        // fetchOrders do not return status, use heuristic\n        if (status === undefined) {\n            if (remaining !== undefined && remaining === 0) {\n                status = 'closed';\n            }\n        }\n        const trades = undefined; // todo: this.parseTrades (order['trades']);\n        let symbol = undefined;\n        if (market !== undefined) {\n            symbol = market['symbol'];\n        }\n        const side = this.safeString (order, 'type');\n        return {\n            'id': id,\n            'clientOrderId': undefined,\n            'timestamp': timestamp,\n            'datetime': this.iso8601 (timestamp),\n            'lastTradeTimestamp': undefined,\n            'amount': amount,\n            'remaining': remaining,\n            'filled': filled,\n            'side': side,\n            'type': undefined,\n            'timeInForce': undefined,\n            'postOnly': undefined,\n            'status': status,\n            'symbol': symbol,\n            'price': price,\n            'stopPrice': undefined,\n            'cost': cost,\n            'trades': trades,\n            'fee': undefined,\n            'info': order,\n            'average': undefined,\n        };\n    }\n\n    async fetchOrder (id, symbol = undefined, params = {}) {\n        await this.loadMarkets ();\n        // a special case for btcbox â€“ default symbol is BTC/JPY\n        if (symbol === undefined) {\n            symbol = 'BTC/JPY';\n        }\n        const market = this.market (symbol);\n        const request = this.extend ({\n            'id': id,\n            'coin': market['baseId'],\n        }, params);\n        const response = await this.privatePostTradeView (this.extend (request, params));\n        return this.parseOrder (response, market);\n    }\n\n    async fetchOrdersByType (type, symbol = undefined, since = undefined, limit = undefined, params = {}) {\n        await this.loadMarkets ();\n        // a special case for btcbox â€“ default symbol is BTC/JPY\n        if (symbol === undefined) {\n            symbol = 'BTC/JPY';\n        }\n        const market = this.market (symbol);\n        const request = {\n            'type': type, // 'open' or 'all'\n            'coin': market['baseId'],\n        };\n        const response = await this.privatePostTradeList (this.extend (request, params));\n        const orders = this.parseOrders (response, market, since, limit);\n        // status (open/closed/canceled) is undefined\n        // btcbox does not return status, but we know it's 'open' as we queried for open orders\n        if (type === 'open') {\n            for (let i = 0; i < orders.length; i++) {\n                orders[i]['status'] = 'open';\n            }\n        }\n        return orders;\n    }\n\n    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {\n        return await this.fetchOrdersByType ('all', symbol, since, limit, params);\n    }\n\n    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {\n        return await this.fetchOrdersByType ('open', symbol, since, limit, params);\n    }\n\n    nonce () {\n        return this.milliseconds ();\n    }\n\n    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {\n        let url = this.urls['api'] + '/' + this.version + '/' + path;\n        if (api === 'public') {\n            if (Object.keys (params).length) {\n                url += '?' + this.urlencode (params);\n            }\n        } else {\n            this.checkRequiredCredentials ();\n            const nonce = this.nonce ().toString ();\n            const query = this.extend ({\n                'key': this.apiKey,\n                'nonce': nonce,\n            }, params);\n            const request = this.urlencode (query);\n            const secret = this.hash (this.encode (this.secret));\n            query['signature'] = this.hmac (this.encode (request), this.encode (secret));\n            body = this.urlencode (query);\n            headers = {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            };\n        }\n        return { 'url': url, 'method': method, 'body': body, 'headers': headers };\n    }\n\n    handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {\n        if (response === undefined) {\n            return; // resort to defaultErrorHandler\n        }\n        // typical error response: {\"result\":false,\"code\":\"401\"}\n        if (httpCode >= 400) {\n            return; // resort to defaultErrorHandler\n        }\n        const result = this.safeValue (response, 'result');\n        if (result === undefined || result === true) {\n            return; // either public API (no error codes expected) or success\n        }\n        const code = this.safeValue (response, 'code');\n        const feedback = this.id + ' ' + body;\n        this.throwExactlyMatchedException (this.exceptions, code, feedback);\n        throw new ExchangeError (feedback); // unknown message\n    }\n\n    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {\n        let response = await this.fetch2 (path, api, method, params, headers, body);\n        if (typeof response === 'string') {\n            // sometimes the exchange returns whitespace prepended to json\n            response = this.strip (response);\n            if (!this.isJsonEncodedObject (response)) {\n                throw new ExchangeError (this.id + ' ' + response);\n            }\n            response = JSON.parse (response);\n        }\n        return response;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}