{"ast":null,"code":"'use strict';\n\nvar curves = require('../curves');\n\nvar utils = require('../utils');\n\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\n\nvar KeyPair = require('./key');\n\nvar Signature = require('./signature');\n\nconst BN = require('../../../../BN/bn.js');\n\nconst {\n  byteArrayToWordArray\n} = require('../../../../../base/functions/encode');\n\nconst CryptoJS = require('../../../../crypto-js/crypto-js');\n\nfunction EDDSA(curveName) {\n  assert(curveName === 'ed25519', 'only tested with ed25519 so far');\n  if (!(this instanceof EDDSA)) return new EDDSA(curveName);\n  var curve = curves[curveName].curve;\n  this.curve = curve;\n  this.g = curve.g;\n  this.g.precompute(curve.n.bitLength() + 1);\n  this.pointClass = curve.point().constructor;\n  this.encodingLength = Math.ceil(curve.n.bitLength() / 8); //this.hash = hash.sha512;\n}\n\nmodule.exports = EDDSA;\n/**\n* @param {Array|String} message - message bytes\n* @param {Array|String|KeyPair} secret - secret bytes or a keypair\n* @returns {Signature} - signature\n*/\n\nEDDSA.prototype.sign = function sign(message, secret) {\n  message = parseBytes(message);\n  var key = this.keyFromSecret(secret);\n  var r = this.hashInt(key.secret(), message);\n  var R = this.g.mul(r);\n  var Rencoded = this.encodePoint(R);\n  var s_ = this.hashInt(Rencoded, key.pubBytes(), message);\n  s_ = s_.mul(key.priv());\n  var S = r.add(s_).umod(this.curve.n);\n  return this.makeSignature({\n    R: R,\n    S: S,\n    Rencoded: Rencoded\n  });\n};\n/**\n * @param {Array|String} message - message bytes\n * @param {Array|String|KeyPair} secret - secret bytes or a keypair\n * @returns {Signature} - signature\n */\n\n\nEDDSA.prototype.signModified = function sign(message, secret) {\n  message = parseBytes(message);\n  var key = this.keyFromSecret(secret); // convert between curve25519 and ed25519 keys\n\n  const secretLE = new BN(key.secret(), 16, 'le');\n  const pubKey = this.encodePoint(this.g.mul(secretLE));\n  const signBit = pubKey[31] & 0x80;\n  var r = this.hashInt(key.secret(), message);\n  var R = this.g.mul(r);\n  var Rencoded = this.encodePoint(R);\n  let s_ = this.hashInt(Rencoded, pubKey, message);\n  s_ = s_.mul(secretLE);\n  var S = r.add(s_).umod(this.curve.n);\n  var Sencoded = S.toArray('le');\n  Sencoded[31] |= signBit;\n  return this.makeSignature({\n    R: R,\n    S: S,\n    Rencoded: Rencoded,\n    Sencoded: Sencoded\n  });\n};\n/**\n* @param {Array} message - message bytes\n* @param {Array|String|Signature} sig - sig bytes\n* @param {Array|String|Point|KeyPair} pub - public key\n* @returns {Boolean} - true if public key matches sig of message\n*/\n\n\nEDDSA.prototype.verify = function verify(message, sig, pub) {\n  message = parseBytes(message);\n  sig = this.makeSignature(sig);\n  var key = this.keyFromPublic(pub);\n  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\n  var SG = this.g.mul(sig.S());\n  var RplusAh = sig.R().add(key.pub().mul(h));\n  return RplusAh.eq(SG);\n};\n\nEDDSA.prototype.hashInt = function hashInt() {\n  let toHash = Array.from(arguments).reduce((a, b) => a.concat(b));\n  toHash = byteArrayToWordArray(toHash);\n  const digest = CryptoJS['SHA512'](toHash).toString(CryptoJS.enc.Hex);\n  return utils.intFromLE(digest).umod(this.curve.n);\n};\n\nEDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\n  return KeyPair.fromPublic(this, pub);\n};\n\nEDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\n  return KeyPair.fromSecret(this, secret);\n};\n\nEDDSA.prototype.makeSignature = function makeSignature(sig) {\n  if (sig instanceof Signature) return sig;\n  return new Signature(this, sig);\n};\n/**\n* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2\n*\n* EDDSA defines methods for encoding and decoding points and integers. These are\n* helper convenience methods, that pass along to utility functions implied\n* parameters.\n*\n*/\n\n\nEDDSA.prototype.encodePoint = function encodePoint(point) {\n  var enc = point.getY().toArray('le', this.encodingLength);\n  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\n  return enc;\n};\n\nEDDSA.prototype.decodePoint = function decodePoint(bytes) {\n  bytes = utils.parseBytes(bytes);\n  var lastIx = bytes.length - 1;\n  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\n  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\n  var y = utils.intFromLE(normed);\n  return this.curve.pointFromY(y, xIsOdd);\n};\n\nEDDSA.prototype.encodeInt = function encodeInt(num) {\n  return num.toArray('le', this.encodingLength);\n};\n\nEDDSA.prototype.decodeInt = function decodeInt(bytes) {\n  return utils.intFromLE(bytes);\n};\n\nEDDSA.prototype.isPoint = function isPoint(val) {\n  return val instanceof this.pointClass;\n};","map":{"version":3,"sources":["C:/Users/senya/Documents/Coding/React Projects/react-stock-ticker/node_modules/ccxt/js/static_dependencies/elliptic/lib/elliptic/eddsa/index.js"],"names":["curves","require","utils","assert","parseBytes","KeyPair","Signature","BN","byteArrayToWordArray","CryptoJS","EDDSA","curveName","curve","g","precompute","n","bitLength","pointClass","point","constructor","encodingLength","Math","ceil","module","exports","prototype","sign","message","secret","key","keyFromSecret","r","hashInt","R","mul","Rencoded","encodePoint","s_","pubBytes","priv","S","add","umod","makeSignature","signModified","secretLE","pubKey","signBit","Sencoded","toArray","verify","sig","pub","keyFromPublic","h","SG","RplusAh","eq","toHash","Array","from","arguments","reduce","a","b","concat","digest","toString","enc","Hex","intFromLE","fromPublic","fromSecret","getY","getX","isOdd","decodePoint","bytes","lastIx","length","normed","slice","xIsOdd","y","pointFromY","encodeInt","num","decodeInt","isPoint","val"],"mappings":"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","sourcesContent":["'use strict';\n\nvar curves = require('../curves');\nvar utils = require('../utils');\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\nconst BN = require ('../../../../BN/bn.js')\nconst { byteArrayToWordArray } = require ('../../../../../base/functions/encode')\nconst CryptoJS = require('../../../../crypto-js/crypto-js');\n\n\nfunction EDDSA(curveName) {\n  assert(curveName === 'ed25519', 'only tested with ed25519 so far');\n\n  if (!(this instanceof EDDSA))\n    return new EDDSA(curveName);\n\n  var curve = curves[curveName].curve;\n  this.curve = curve;\n  this.g = curve.g;\n  this.g.precompute(curve.n.bitLength() + 1);\n\n  this.pointClass = curve.point().constructor;\n  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);\n  //this.hash = hash.sha512;\n}\n\nmodule.exports = EDDSA;\n\n/**\n* @param {Array|String} message - message bytes\n* @param {Array|String|KeyPair} secret - secret bytes or a keypair\n* @returns {Signature} - signature\n*/\nEDDSA.prototype.sign = function sign(message, secret) {\n  message = parseBytes(message);\n  var key = this.keyFromSecret(secret);\n  var r = this.hashInt(key.secret (), message);\n  var R = this.g.mul(r);\n  var Rencoded = this.encodePoint(R);\n  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)\n  s_ = s_.mul (key.priv ())\n  var S = r.add(s_).umod(this.curve.n);\n  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });\n};\n\n/**\n * @param {Array|String} message - message bytes\n * @param {Array|String|KeyPair} secret - secret bytes or a keypair\n * @returns {Signature} - signature\n */\nEDDSA.prototype.signModified = function sign(message, secret) {\n  message = parseBytes(message);\n  var key = this.keyFromSecret(secret);\n  // convert between curve25519 and ed25519 keys\n  const secretLE = new BN (key.secret (), 16, 'le')\n  const pubKey = this.encodePoint (this.g.mul (secretLE))\n  const signBit = pubKey[31] & 0x80\n  var r = this.hashInt (key.secret (), message)\n  var R = this.g.mul(r);\n  var Rencoded = this.encodePoint (R);\n  let s_ = this.hashInt (Rencoded, pubKey, message)\n  s_ = s_.mul (secretLE)\n  var S = r.add(s_).umod(this.curve.n);\n  var Sencoded = S.toArray ('le')\n  Sencoded[31] |= signBit\n  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded, Sencoded: Sencoded });\n};\n\n\n/**\n* @param {Array} message - message bytes\n* @param {Array|String|Signature} sig - sig bytes\n* @param {Array|String|Point|KeyPair} pub - public key\n* @returns {Boolean} - true if public key matches sig of message\n*/\nEDDSA.prototype.verify = function verify(message, sig, pub) {\n  message = parseBytes(message);\n  sig = this.makeSignature(sig);\n  var key = this.keyFromPublic(pub);\n  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\n  var SG = this.g.mul(sig.S());\n  var RplusAh = sig.R().add(key.pub().mul(h));\n  return RplusAh.eq(SG);\n};\n\nEDDSA.prototype.hashInt = function hashInt() {\n  let toHash = Array.from (arguments).reduce ((a, b) => a.concat (b))\n  toHash = byteArrayToWordArray (toHash)\n  const digest = CryptoJS['SHA512'] (toHash).toString (CryptoJS.enc.Hex)\n  return utils.intFromLE(digest).umod(this.curve.n);\n};\n\nEDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\n  return KeyPair.fromPublic(this, pub);\n};\n\nEDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\n  return KeyPair.fromSecret(this, secret);\n};\n\nEDDSA.prototype.makeSignature = function makeSignature(sig) {\n  if (sig instanceof Signature)\n    return sig;\n  return new Signature(this, sig);\n};\n\n/**\n* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2\n*\n* EDDSA defines methods for encoding and decoding points and integers. These are\n* helper convenience methods, that pass along to utility functions implied\n* parameters.\n*\n*/\nEDDSA.prototype.encodePoint = function encodePoint(point) {\n  var enc = point.getY().toArray('le', this.encodingLength);\n  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\n  return enc;\n};\n\nEDDSA.prototype.decodePoint = function decodePoint(bytes) {\n  bytes = utils.parseBytes(bytes);\n\n  var lastIx = bytes.length - 1;\n  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\n  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\n\n  var y = utils.intFromLE(normed);\n  return this.curve.pointFromY(y, xIsOdd);\n};\n\nEDDSA.prototype.encodeInt = function encodeInt(num) {\n  return num.toArray('le', this.encodingLength);\n};\n\nEDDSA.prototype.decodeInt = function decodeInt(bytes) {\n  return utils.intFromLE(bytes);\n};\n\nEDDSA.prototype.isPoint = function isPoint(val) {\n  return val instanceof this.pointClass;\n};\n"]},"metadata":{},"sourceType":"script"}