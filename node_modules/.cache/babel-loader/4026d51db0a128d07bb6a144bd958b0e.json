{"ast":null,"code":"'use strict';\n/*  ------------------------------------------------------------------------ */\n\nconst now = Date.now; // TODO: figure out how to utilize performance.now () properly â€“ it's not as easy as it does not return a unix timestamp...\n\nconst microseconds = () => now() * 1000; // TODO: utilize performance.now for that purpose\n\n\nconst milliseconds = now;\n\nconst seconds = () => Math.floor(now() / 1000);\n\nconst uuidv1 = () => {\n  const biasSeconds = 12219292800; // seconds from 15th Oct 1572 to Jan 1st 1970\n\n  const bias = biasSeconds * 10000000; // in hundreds of nanoseconds\n\n  const time = microseconds() * 10 + bias;\n  const timeHex = time.toString(16);\n  const arranged = timeHex.slice(7, 15) + timeHex.slice(3, 7) + '1' + timeHex.slice(0, 3); // these should be random, but we're not making more than 10 requests per microsecond so who cares\n\n  const clockId = '9696'; // a 14 bit number\n\n  const macAddress = 'ff'.repeat(6);\n  return arranged + clockId + macAddress;\n};\n/*  ------------------------------------------------------------------------ */\n\n\nconst setTimeout_original = setTimeout;\n\nconst setTimeout_safe = (done, ms, setTimeout = setTimeout_original\n/* overrideable for mocking purposes */\n, targetTime = now() + ms) => {\n  /*  The built-in setTimeout function can fire its callback earlier than specified, so we\n      need to ensure that it does not happen: sleep recursively until `targetTime` is reached...   */\n  let clearInnerTimeout = () => {};\n\n  let active = true;\n  const id = setTimeout(() => {\n    active = true;\n    const rest = targetTime - now();\n\n    if (rest > 0) {\n      clearInnerTimeout = setTimeout_safe(done, rest, setTimeout, targetTime); // try sleep more\n    } else {\n      done();\n    }\n  }, ms);\n  return function clear() {\n    if (active) {\n      active = false; // dunno if IDs are unique on various platforms, so it's better to rely on this flag to exclude the possible cancellation of the wrong timer (if called after completion)\n\n      clearTimeout(id);\n    }\n\n    clearInnerTimeout();\n  };\n};\n/*  ------------------------------------------------------------------------ */\n\n\nclass TimedOut extends Error {\n  constructor() {\n    const message = 'timed out';\n    super(message);\n    this.constructor = TimedOut;\n    this.__proto__ = TimedOut.prototype;\n    this.message = message;\n  }\n\n}\n/*  ------------------------------------------------------------------------ */\n\n\nconst iso8601 = timestamp => {\n  let _timestampNumber = undefined;\n\n  if (typeof timestamp === 'number') {\n    _timestampNumber = Math.floor(timestamp);\n  } else {\n    _timestampNumber = parseInt(timestamp, 10);\n  } // undefined, null and lots of nasty non-numeric values yield NaN\n\n\n  if (Number.isNaN(_timestampNumber) || _timestampNumber < 0) {\n    return undefined;\n  } // last line of defence\n\n\n  try {\n    return new Date(_timestampNumber).toISOString();\n  } catch (e) {\n    return undefined;\n  }\n};\n\nconst parse8601 = x => {\n  if (typeof x !== 'string' || !x) {\n    return undefined;\n  }\n\n  if (x.match(/^[0-9]+$/)) {\n    // a valid number in a string, not a date.\n    return undefined;\n  }\n\n  if (x.indexOf('-') < 0 || x.indexOf(':') < 0) {\n    // no date can be without a dash and a colon\n    return undefined;\n  } // last line of defence\n\n\n  try {\n    const candidate = Date.parse(x.indexOf('+') >= 0 || x.slice(-1) === 'Z' ? x : (x + 'Z').replace(/\\s(\\d\\d):/, 'T$1:'));\n\n    if (Number.isNaN(candidate)) {\n      return undefined;\n    }\n\n    return candidate;\n  } catch (e) {\n    return undefined;\n  }\n};\n\nconst parseDate = x => {\n  if (typeof x !== 'string' || !x) {\n    return undefined;\n  }\n\n  if (x.indexOf('GMT') >= 0) {\n    try {\n      return Date.parse(x);\n    } catch (e) {\n      return undefined;\n    }\n  }\n\n  return parse8601(x);\n};\n\nconst rfc2616 = (timestamp = undefined) => {\n  return new Date(timestamp).toUTCString();\n};\n\nconst mdy = (timestamp, infix = '-') => {\n  infix = infix || '';\n  const date = new Date(timestamp);\n  const Y = date.getUTCFullYear().toString();\n  let m = date.getUTCMonth() + 1;\n  let d = date.getUTCDate();\n  m = m < 10 ? '0' + m : m.toString();\n  d = d < 10 ? '0' + d : d.toString();\n  return m + infix + d + infix + Y;\n};\n\nconst ymd = (timestamp, infix = '-') => {\n  infix = infix || '';\n  const date = new Date(timestamp);\n  const Y = date.getUTCFullYear().toString();\n  let m = date.getUTCMonth() + 1;\n  let d = date.getUTCDate();\n  m = m < 10 ? '0' + m : m.toString();\n  d = d < 10 ? '0' + d : d.toString();\n  return Y + infix + m + infix + d;\n};\n\nconst ymdhms = (timestamp, infix = ' ') => {\n  const date = new Date(timestamp);\n  const Y = date.getUTCFullYear();\n  let m = date.getUTCMonth() + 1;\n  let d = date.getUTCDate();\n  let H = date.getUTCHours();\n  let M = date.getUTCMinutes();\n  let S = date.getUTCSeconds();\n  m = m < 10 ? '0' + m : m;\n  d = d < 10 ? '0' + d : d;\n  H = H < 10 ? '0' + H : H;\n  M = M < 10 ? '0' + M : M;\n  S = S < 10 ? '0' + S : S;\n  return Y + '-' + m + '-' + d + infix + H + ':' + M + ':' + S;\n};\n\nmodule.exports = {\n  now,\n  microseconds,\n  milliseconds,\n  seconds,\n  iso8601,\n  parse8601,\n  rfc2616,\n  uuidv1,\n  parseDate,\n  mdy,\n  ymd,\n  ymdhms,\n  setTimeout_safe,\n  sleep: ms => new Promise(resolve => setTimeout_safe(resolve, ms)),\n  TimedOut,\n  timeout: async (ms, promise) => {\n    let clear = () => {};\n\n    const expires = new Promise(resolve => clear = setTimeout_safe(resolve, ms));\n\n    try {\n      return await Promise.race([promise, expires.then(() => {\n        throw new TimedOut();\n      })]);\n    } finally {\n      clear(); // fixes https://github.com/ccxt/ccxt/issues/749\n    }\n  }\n};\n/*  ------------------------------------------------------------------------ */","map":{"version":3,"sources":["C:/Users/senya/Documents/Coding/React Projects/react-stock-ticker/node_modules/ccxt/js/base/functions/time.js"],"names":["now","Date","microseconds","milliseconds","seconds","Math","floor","uuidv1","biasSeconds","bias","time","timeHex","toString","arranged","slice","clockId","macAddress","repeat","setTimeout_original","setTimeout","setTimeout_safe","done","ms","targetTime","clearInnerTimeout","active","id","rest","clear","clearTimeout","TimedOut","Error","constructor","message","__proto__","prototype","iso8601","timestamp","_timestampNumber","undefined","parseInt","Number","isNaN","toISOString","e","parse8601","x","match","indexOf","candidate","parse","replace","parseDate","rfc2616","toUTCString","mdy","infix","date","Y","getUTCFullYear","m","getUTCMonth","d","getUTCDate","ymd","ymdhms","H","getUTCHours","M","getUTCMinutes","S","getUTCSeconds","module","exports","sleep","Promise","resolve","timeout","promise","expires","race","then"],"mappings":"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","sourcesContent":["'use strict';\n\n/*  ------------------------------------------------------------------------ */\n\nconst now = Date.now // TODO: figure out how to utilize performance.now () properly â€“ it's not as easy as it does not return a unix timestamp...\nconst microseconds = () => now () * 1000 // TODO: utilize performance.now for that purpose\nconst milliseconds = now\nconst seconds      = () => Math.floor (now () / 1000)\nconst uuidv1 = () => {\n    const biasSeconds = 12219292800  // seconds from 15th Oct 1572 to Jan 1st 1970\n    const bias = biasSeconds * 10000000  // in hundreds of nanoseconds\n    const time = microseconds () * 10 + bias\n    const timeHex = time.toString (16)\n    const arranged = timeHex.slice (7, 15) + timeHex.slice (3, 7) + '1' + timeHex.slice (0, 3)\n    // these should be random, but we're not making more than 10 requests per microsecond so who cares\n    const clockId = '9696' // a 14 bit number\n    const macAddress = 'ff'.repeat (6)\n    return arranged + clockId + macAddress\n}\n\n/*  ------------------------------------------------------------------------ */\n\nconst setTimeout_original = setTimeout\nconst setTimeout_safe = (done, ms, setTimeout = setTimeout_original /* overrideable for mocking purposes */, targetTime = now () + ms) => {\n\n/*  The built-in setTimeout function can fire its callback earlier than specified, so we\n    need to ensure that it does not happen: sleep recursively until `targetTime` is reached...   */\n\n    let clearInnerTimeout = () => {}\n    let active = true\n\n    const id = setTimeout (() => {\n        active = true\n        const rest = targetTime - now ()\n        if (rest > 0) {\n            clearInnerTimeout = setTimeout_safe (done, rest, setTimeout, targetTime) // try sleep more\n        } else {\n            done ()\n        }\n    }, ms)\n\n    return function clear () {\n        if (active) {\n            active = false // dunno if IDs are unique on various platforms, so it's better to rely on this flag to exclude the possible cancellation of the wrong timer (if called after completion)\n            clearTimeout (id)\n        }\n        clearInnerTimeout ()\n    }\n}\n\n/*  ------------------------------------------------------------------------ */\n\nclass TimedOut extends Error {\n\n    constructor () {\n        const message = 'timed out'\n        super (message)\n        this.constructor = TimedOut\n        this.__proto__   = TimedOut.prototype\n        this.message     = message\n    }\n}\n\n/*  ------------------------------------------------------------------------ */\n\nconst iso8601 = (timestamp) => {\n    let _timestampNumber = undefined;\n    if (typeof timestamp === 'number') {\n        _timestampNumber = Math.floor (timestamp);\n    } else {\n        _timestampNumber = parseInt (timestamp, 10);\n    }\n\n    // undefined, null and lots of nasty non-numeric values yield NaN\n    if (Number.isNaN (_timestampNumber) || _timestampNumber < 0) {\n        return undefined;\n    }\n\n    // last line of defence\n    try {\n        return new Date (_timestampNumber).toISOString ();\n    } catch (e) {\n        return undefined;\n    }\n}\n\nconst parse8601 = (x) => {\n    if (typeof x !== 'string' || !x) {\n        return undefined;\n    }\n\n    if (x.match (/^[0-9]+$/)) {\n        // a valid number in a string, not a date.\n        return undefined;\n    }\n\n    if (x.indexOf ('-') < 0 || x.indexOf (':') < 0) { // no date can be without a dash and a colon\n        return undefined;\n    }\n\n    // last line of defence\n    try {\n        const candidate = Date.parse (((x.indexOf ('+') >= 0) || (x.slice (-1) === 'Z')) ? x : (x + 'Z').replace (/\\s(\\d\\d):/, 'T$1:'));\n        if (Number.isNaN (candidate)) {\n            return undefined;\n        }\n        return candidate;\n    } catch (e) {\n        return undefined;\n    }\n}\n\nconst parseDate = (x) => {\n    if (typeof x !== 'string' || !x) {\n        return undefined;\n    }\n\n    if (x.indexOf ('GMT') >= 0) {\n        try {\n            return Date.parse (x);\n        } catch (e) {\n            return undefined;\n        }\n    }\n\n    return parse8601 (x);\n}\n\nconst rfc2616 = (timestamp = undefined) => {\n    return new Date (timestamp).toUTCString ();\n}\n\nconst mdy = (timestamp, infix = '-') => {\n    infix = infix || ''\n    const date = new Date (timestamp)\n    const Y = date.getUTCFullYear ().toString ()\n    let m = date.getUTCMonth () + 1\n    let d = date.getUTCDate ()\n    m = m < 10 ? ('0' + m) : m.toString ()\n    d = d < 10 ? ('0' + d) : d.toString ()\n    return m + infix + d + infix + Y\n}\n\nconst ymd = (timestamp, infix = '-') => {\n    infix = infix || ''\n    const date = new Date (timestamp)\n    const Y = date.getUTCFullYear ().toString ()\n    let m = date.getUTCMonth () + 1\n    let d = date.getUTCDate ()\n    m = m < 10 ? ('0' + m) : m.toString ()\n    d = d < 10 ? ('0' + d) : d.toString ()\n    return Y + infix + m + infix + d\n}\n\nconst ymdhms = (timestamp, infix = ' ') => {\n    const date = new Date (timestamp)\n    const Y = date.getUTCFullYear ()\n    let m = date.getUTCMonth () + 1\n    let d = date.getUTCDate ()\n    let H = date.getUTCHours ()\n    let M = date.getUTCMinutes ()\n    let S = date.getUTCSeconds ()\n    m = m < 10 ? ('0' + m) : m\n    d = d < 10 ? ('0' + d) : d\n    H = H < 10 ? ('0' + H) : H\n    M = M < 10 ? ('0' + M) : M\n    S = S < 10 ? ('0' + S) : S\n    return Y + '-' + m + '-' + d + infix + H + ':' + M + ':' + S\n}\n\nmodule.exports =\n\n    {\n        now\n        , microseconds\n        , milliseconds\n        , seconds\n        , iso8601\n        , parse8601\n        , rfc2616\n        , uuidv1\n        , parseDate\n        , mdy\n        , ymd\n        , ymdhms\n        , setTimeout_safe\n        , sleep: ms => new Promise (resolve => setTimeout_safe (resolve, ms))\n        , TimedOut\n        , timeout: async (ms, promise) => {\n\n            let clear = () => {}\n            const expires = new Promise (resolve => (clear = setTimeout_safe (resolve, ms)))\n\n            try {\n                return await Promise.race ([promise, expires.then (() => { throw new TimedOut () })])\n            } finally {\n                clear () // fixes https://github.com/ccxt/ccxt/issues/749\n            }\n        }\n}\n\n/*  ------------------------------------------------------------------------ */\n"]},"metadata":{},"sourceType":"script"}