{"ast":null,"code":"\"use strict\"; // ----------------------------------------------------------------------------\n\nconst {\n  isObject,\n  isNumber,\n  isDictionary,\n  isArray\n} = require('./type'); // ----------------------------------------------------------------------------\n\n\nconst keys = Object.keys,\n      values = x => !isArray(x) ? Object.values(x) : x // don't copy arrays if they're already arrays\n,\n      index = x => new Set(values(x)),\n      extend = (...args) => Object.assign({}, ...args) // NB: side-effect free\n,\n      clone = x => isArray(x) ? Array.from(x) : extend(x); // clone arrays or objects\n// ----------------------------------------------------------------------------\n\n\nmodule.exports = {\n  keys,\n  values,\n  extend,\n  clone,\n  index,\n  ordered: x => x // a stub to keep assoc keys in order (in JS it does nothing, it's mostly for Python)\n  ,\n  unique: x => Array.from(index(x)),\n  arrayConcat: (a, b) => a.concat(b) // ------------------------------------------------------------------------\n  ,\n\n  inArray(needle, haystack) {\n    return haystack.includes(needle);\n  },\n\n  toArray(object) {\n    return Object.values(object);\n  },\n\n  isEmpty(object) {\n    if (!object) {\n      return true;\n    }\n\n    return (Array.isArray(object) ? object : Object.keys(object)).length < 1;\n  } // ------------------------------------------------------------------------\n  ,\n\n  keysort(x, out = {}) {\n    for (const k of keys(x).sort()) out[k] = x[k];\n\n    return out;\n  } // ------------------------------------------------------------------------\n\n  /*\n      Accepts a map/array of objects and a key name to be used as an index:\n      array = [\n          { someKey: 'value1', anotherKey: 'anotherValue1' },\n          { someKey: 'value2', anotherKey: 'anotherValue2' },\n          { someKey: 'value3', anotherKey: 'anotherValue3' },\n      ]\n      key = 'someKey'\n       Returns a map:\n      {\n          value1: { someKey: 'value1', anotherKey: 'anotherValue1' },\n          value2: { someKey: 'value2', anotherKey: 'anotherValue2' },\n          value3: { someKey: 'value3', anotherKey: 'anotherValue3' },\n      }\n  */\n  ,\n\n  indexBy(x, k, out = {}) {\n    for (const v of values(x)) {\n      if (k in v) {\n        out[v[k]] = v;\n      }\n    }\n\n    return out;\n  } // ------------------------------------------------------------------------\n\n  /*\n      Accepts a map/array of objects and a key name to be used as a grouping parameter:\n      array = [\n          { someKey: 'value1', anotherKey: 'anotherValue1' },\n          { someKey: 'value1', anotherKey: 'anotherValue2' },\n          { someKey: 'value3', anotherKey: 'anotherValue3' },\n      ]\n      key = 'someKey'\n       Returns a map:\n      {\n          value1: [\n              { someKey: 'value1', anotherKey: 'anotherValue1' },\n              { someKey: 'value1', anotherKey: 'anotherValue2' },\n          ]\n          value3: [\n              { someKey: 'value3', anotherKey: 'anotherValue3' }\n          ],\n      }\n  */\n  ,\n\n  groupBy(x, k, out = {}) {\n    for (const v of values(x)) {\n      if (k in v) {\n        const p = v[k];\n        out[p] = out[p] || [];\n        out[p].push(v);\n      }\n    }\n\n    return out;\n  } // ------------------------------------------------------------------------\n\n  /*\n      Accepts a map/array of objects, a key name and a key value to be used as a filter:\n      array = [\n          { someKey: 'value1', anotherKey: 'anotherValue1' },\n          { someKey: 'value2', anotherKey: 'anotherValue2' },\n          { someKey: 'value3', anotherKey: 'anotherValue3' },\n      ]\n      key = 'someKey'\n      value = 'value1'\n       Returns an array:\n      [\n          value1: { someKey: 'value1', anotherKey: 'anotherValue1' },\n      ]\n  */\n  ,\n\n  filterBy(x, k, value = undefined, out = []) {\n    for (const v of values(x)) {\n      if (v[k] === value) {\n        out.push(v);\n      }\n    }\n\n    return out;\n  } // ------------------------------------------------------------------------\n  // NB: MUTATES ARRAY!\n  ,\n\n  sortBy: (array, key, descending = false, direction = descending ? -1 : 1) => array.sort((a, b) => {\n    if (a[key] < b[key]) {\n      return -direction;\n    } else if (a[key] > b[key]) {\n      return direction;\n    } else {\n      return 0;\n    }\n  }) // ------------------------------------------------------------------------\n  ,\n  flatten: function flatten(x, out = []) {\n    for (const v of x) {\n      if (isArray(v)) {\n        flatten(v, out);\n      } else {\n        out.push(v);\n      }\n    }\n\n    return out;\n  } // ------------------------------------------------------------------------\n  ,\n  pluck: (x, k) => values(x).filter(v => k in v).map(v => v[k]) // ------------------------------------------------------------------------\n  ,\n\n  omit(x, ...args) {\n    if (!Array.isArray(x)) {\n      const out = clone(x);\n\n      for (const k of args) {\n        if (isArray(k)) {\n          // omit (x, ['a', 'b'])\n          for (const kk of k) {\n            delete out[kk];\n          }\n        } else {\n          delete out[k]; // omit (x, 'a', 'b')\n        }\n      }\n\n      return out;\n    }\n\n    return x;\n  } // ------------------------------------------------------------------------\n  ,\n\n  sum(...xs) {\n    const ns = xs.filter(isNumber); // leave only numbers\n\n    return ns.length > 0 ? ns.reduce((a, b) => a + b, 0) : undefined;\n  } // ------------------------------------------------------------------------\n  ,\n\n  deepExtend: function deepExtend(...xs) {\n    let out = undefined;\n\n    for (const x of xs) {\n      if (isDictionary(x)) {\n        if (!isDictionary(out)) {\n          out = {};\n        }\n\n        for (const k in x) {\n          out[k] = deepExtend(out[k], x[k]);\n        }\n      } else {\n        out = x;\n      }\n    }\n\n    return out;\n  } // ----------------------------------------------------------------------------\n\n};","map":{"version":3,"sources":["C:/Users/senya/Documents/Coding/React Projects/react-stock-ticker/node_modules/ccxt/js/base/functions/generic.js"],"names":["isObject","isNumber","isDictionary","isArray","require","keys","Object","values","x","index","Set","extend","args","assign","clone","Array","from","module","exports","ordered","unique","arrayConcat","a","b","concat","inArray","needle","haystack","includes","toArray","object","isEmpty","length","keysort","out","k","sort","indexBy","v","groupBy","p","push","filterBy","value","undefined","sortBy","array","key","descending","direction","flatten","pluck","filter","map","omit","kk","sum","xs","ns","reduce","deepExtend"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// ----------------------------------------------------------------------------\n\nconst { isObject, isNumber, isDictionary, isArray } = require ('./type')\n\n// ----------------------------------------------------------------------------\n\nconst keys = Object.keys\n    , values = (x) => ((!isArray (x)) ? Object.values (x) : x) // don't copy arrays if they're already arrays\n    , index = (x) => new Set (values (x))\n    , extend = (...args) => Object.assign ({}, ...args) // NB: side-effect free\n    , clone = (x) => (isArray (x) ? Array.from (x) : extend (x)) // clone arrays or objects\n\n// ----------------------------------------------------------------------------\n\nmodule.exports = {\n    keys\n    , values\n    , extend\n    , clone\n    , index\n    , ordered: (x) => x // a stub to keep assoc keys in order (in JS it does nothing, it's mostly for Python)\n    , unique: (x) => Array.from (index (x))\n    , arrayConcat: (a, b) => a.concat (b)\n\n    // ------------------------------------------------------------------------\n\n    , inArray (needle, haystack) {\n\n        return haystack.includes (needle)\n    }\n\n    , toArray (object) {\n\n        return Object.values (object)\n    }\n\n    , isEmpty (object) {\n        if (!object) {\n            return true\n        }\n        return (Array.isArray (object) ? object : Object.keys (object)).length < 1;\n    }\n\n    // ------------------------------------------------------------------------\n\n    , keysort (x, out = {}) {\n\n        for (const k of keys (x).sort ())\n            out[k] = x[k]\n\n        return out\n    }\n\n    // ------------------------------------------------------------------------\n\n    /*\n        Accepts a map/array of objects and a key name to be used as an index:\n        array = [\n            { someKey: 'value1', anotherKey: 'anotherValue1' },\n            { someKey: 'value2', anotherKey: 'anotherValue2' },\n            { someKey: 'value3', anotherKey: 'anotherValue3' },\n        ]\n        key = 'someKey'\n\n        Returns a map:\n        {\n            value1: { someKey: 'value1', anotherKey: 'anotherValue1' },\n            value2: { someKey: 'value2', anotherKey: 'anotherValue2' },\n            value3: { someKey: 'value3', anotherKey: 'anotherValue3' },\n        }\n    */\n\n    , indexBy (x, k, out = {}) {\n\n        for (const v of values (x)) {\n            if (k in v) {\n                out[v[k]] = v\n            }\n        }\n\n        return out\n    }\n\n    // ------------------------------------------------------------------------\n\n    /*\n        Accepts a map/array of objects and a key name to be used as a grouping parameter:\n        array = [\n            { someKey: 'value1', anotherKey: 'anotherValue1' },\n            { someKey: 'value1', anotherKey: 'anotherValue2' },\n            { someKey: 'value3', anotherKey: 'anotherValue3' },\n        ]\n        key = 'someKey'\n\n        Returns a map:\n        {\n            value1: [\n                { someKey: 'value1', anotherKey: 'anotherValue1' },\n                { someKey: 'value1', anotherKey: 'anotherValue2' },\n            ]\n            value3: [\n                { someKey: 'value3', anotherKey: 'anotherValue3' }\n            ],\n        }\n    */\n\n    , groupBy (x, k, out = {}) {\n\n        for (const v of values (x)) {\n            if (k in v) {\n                const p = v[k]\n                out[p] = out[p] || []\n                out[p].push (v)\n            }\n        }\n        return out\n    }\n\n    // ------------------------------------------------------------------------\n\n    /*\n        Accepts a map/array of objects, a key name and a key value to be used as a filter:\n        array = [\n            { someKey: 'value1', anotherKey: 'anotherValue1' },\n            { someKey: 'value2', anotherKey: 'anotherValue2' },\n            { someKey: 'value3', anotherKey: 'anotherValue3' },\n        ]\n        key = 'someKey'\n        value = 'value1'\n\n        Returns an array:\n        [\n            value1: { someKey: 'value1', anotherKey: 'anotherValue1' },\n        ]\n    */\n\n    , filterBy (x, k, value = undefined, out = []) {\n\n        for (const v of values (x)) {\n            if (v[k] === value) {\n                out.push (v)\n            }\n        }\n\n        return out\n    }\n\n    // ------------------------------------------------------------------------\n    // NB: MUTATES ARRAY!\n\n    , sortBy: (array, key, descending = false, direction  = descending ? -1 : 1) => array.sort ((a, b) => {\n        if (a[key] < b[key]) {\n            return -direction\n        } else if (a[key] > b[key]) {\n            return direction\n        } else {\n            return 0\n        }\n    })\n\n    // ------------------------------------------------------------------------\n\n    , flatten: function flatten (x, out = []) {\n\n        for (const v of x) {\n            if (isArray (v)) {\n                flatten (v, out)\n            } else {\n                out.push (v)\n            }\n        }\n\n        return out\n    }\n\n    // ------------------------------------------------------------------------\n\n    , pluck: (x, k) => values (x).filter ((v) => k in v).map ((v) => v[k])\n\n    // ------------------------------------------------------------------------\n\n    , omit (x, ...args) {\n\n        if (!Array.isArray (x)) {\n\n            const out = clone (x)\n\n            for (const k of args) {\n                if (isArray (k)) { // omit (x, ['a', 'b'])\n                    for (const kk of k) {\n                        delete out[kk]\n                    }\n                } else {\n                    delete out[k] // omit (x, 'a', 'b')\n                }\n            }\n\n            return out\n        }\n\n        return x\n    }\n\n    // ------------------------------------------------------------------------\n\n    , sum (...xs) {\n\n        const ns = xs.filter (isNumber) // leave only numbers\n\n        return (ns.length > 0) ? ns.reduce ((a, b) => a + b, 0) : undefined\n    }\n\n    // ------------------------------------------------------------------------\n\n    , deepExtend: function deepExtend (...xs) {\n        let out = undefined\n        for (const x of xs) {\n            if (isDictionary (x)) {\n                if (!isDictionary (out)) {\n                    out = {}\n                }\n                for (const k in x) {\n                    out[k] = deepExtend (out[k], x[k])\n                }\n            } else {\n                out = x\n            }\n        }\n        return out\n    }\n\n// ----------------------------------------------------------------------------\n\n}\n"]},"metadata":{},"sourceType":"script"}