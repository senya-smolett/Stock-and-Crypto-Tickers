{"ast":null,"code":"'use strict';\n\nconst errorHierarchy = require('./errorHierarchy.js');\n/*  ------------------------------------------------------------------------ */\n\n\nfunction subclass(BaseClass, classes, namespace = {}) {\n  for (const [className, subclasses] of Object.entries(classes)) {\n    const Class = Object.assign(namespace, {\n      /*  By creating a named property, we trick compiler to assign our class constructor function a name.\n          Otherwise, all our error constructors would be shown as [Function: Error] in the debugger! And\n          the super-useful `e.constructor.name` magic wouldn't work — we then would have no chance to\n          obtain a error type string from an error instance programmatically!                               */\n      [className]: class extends BaseClass {\n        constructor(message) {\n          super(message);\n          /*  A workaround to make `instanceof` work on custom Error classes in transpiled ES5.\n              See my blog post for the explanation of this hack:\n               https://medium.com/@xpl/javascript-deriving-from-error-properly-8d2f8f315801        */\n\n          this.constructor = Class;\n          this.__proto__ = Class.prototype;\n          this.name = className;\n          this.message = message; // https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work\n\n          Object.setPrototypeOf(this, Class.prototype);\n        }\n\n      }\n    })[className];\n    subclass(Class, subclasses, namespace);\n  }\n\n  return namespace;\n}\n/*  ------------------------------------------------------------------------ */\n\n\nmodule.exports = subclass( // Root class\nError, // Derived class hierarchy\nerrorHierarchy);","map":{"version":3,"sources":["C:/Users/senya/Documents/Coding/React Projects/react-stock-ticker/node_modules/ccxt/js/base/errors.js"],"names":["errorHierarchy","require","subclass","BaseClass","classes","namespace","className","subclasses","Object","entries","Class","assign","constructor","message","__proto__","prototype","name","setPrototypeOf","module","exports","Error"],"mappings":"AAAA;;AAEA,MAAMA,cAAc,GAAGC,OAAO,CAAE,qBAAF,CAA9B;AAEA;;;AAEA,SAASC,QAAT,CAAmBC,SAAnB,EAA8BC,OAA9B,EAAuCC,SAAS,GAAG,EAAnD,EAAuD;AAEnD,OAAK,MAAM,CAACC,SAAD,EAAYC,UAAZ,CAAX,IAAsCC,MAAM,CAACC,OAAP,CAAgBL,OAAhB,CAAtC,EAAgE;AAE5D,UAAMM,KAAK,GAAGF,MAAM,CAACG,MAAP,CAAeN,SAAf,EAA0B;AAExC;AACR;AACA;AACA;AAEY,OAACC,SAAD,GAAa,cAAcH,SAAd,CAAwB;AAEjCS,QAAAA,WAAW,CAAEC,OAAF,EAAW;AAElB,gBAAOA,OAAP;AAEJ;AAChB;AACA;;AAGoB,eAAKD,WAAL,GAAmBF,KAAnB;AACA,eAAKI,SAAL,GAAmBJ,KAAK,CAACK,SAAzB;AACA,eAAKC,IAAL,GAAmBV,SAAnB;AACA,eAAKO,OAAL,GAAmBA,OAAnB,CAZkB,CAclB;;AAEAL,UAAAA,MAAM,CAACS,cAAP,CAAuB,IAAvB,EAA6BP,KAAK,CAACK,SAAnC;AACH;;AAnBgC;AAPD,KAA1B,EA6BXT,SA7BW,CAAd;AA+BAJ,IAAAA,QAAQ,CAAEQ,KAAF,EAASH,UAAT,EAAqBF,SAArB,CAAR;AACH;;AAED,SAAOA,SAAP;AACH;AAED;;;AAEAa,MAAM,CAACC,OAAP,GAAiBjB,QAAQ,EACrB;AACAkB,KAFqB,EAGrB;AACApB,cAJqB,CAAzB","sourcesContent":["'use strict';\n\nconst errorHierarchy = require ('./errorHierarchy.js')\n\n/*  ------------------------------------------------------------------------ */\n\nfunction subclass (BaseClass, classes, namespace = {}) {\n\n    for (const [className, subclasses] of Object.entries (classes)) {\n\n        const Class = Object.assign (namespace, {\n\n        /*  By creating a named property, we trick compiler to assign our class constructor function a name.\n            Otherwise, all our error constructors would be shown as [Function: Error] in the debugger! And\n            the super-useful `e.constructor.name` magic wouldn't work — we then would have no chance to\n            obtain a error type string from an error instance programmatically!                               */\n\n            [className]: class extends BaseClass {\n\n                constructor (message) {\n\n                    super (message)\n\n                /*  A workaround to make `instanceof` work on custom Error classes in transpiled ES5.\n                    See my blog post for the explanation of this hack:\n\n                    https://medium.com/@xpl/javascript-deriving-from-error-properly-8d2f8f315801        */\n\n                    this.constructor = Class\n                    this.__proto__   = Class.prototype\n                    this.name        = className\n                    this.message     = message\n\n                    // https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work\n\n                    Object.setPrototypeOf (this, Class.prototype)\n                }\n            }\n\n        })[className]\n\n        subclass (Class, subclasses, namespace)\n    }\n\n    return namespace\n}\n\n/*  ------------------------------------------------------------------------ */\n\nmodule.exports = subclass (\n    // Root class\n    Error,\n    // Derived class hierarchy\n    errorHierarchy\n)\n"]},"metadata":{},"sourceType":"script"}