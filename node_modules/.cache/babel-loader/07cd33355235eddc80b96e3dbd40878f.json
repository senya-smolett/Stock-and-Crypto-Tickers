{"ast":null,"code":"'use strict';\n/*  ------------------------------------------------------------------------\n\n    NB: initially, I used objects for options passing:\n\n            decimalToPrecision ('123.456', { digits: 2, round: true, afterPoint: true })\n\n    ...but it turns out it's hard to port that across different languages and it is also\n       probably has a performance penalty -- while it's a performance critical code! So\n       I switched to using named constants instead, as it is actually more readable and\n       succinct, and surely doesn't come with any inherent performance downside:\n\n            decimalToPrecision ('123.456', ROUND, 2, DECIMAL_PLACES)                     */\n\nconst ROUND = 0 // rounding mode\n,\n      TRUNCATE = 1,\n      ROUND_UP = 2,\n      ROUND_DOWN = 3;\nconst DECIMAL_PLACES = 0 // digits counting mode\n,\n      SIGNIFICANT_DIGITS = 1,\n      TICK_SIZE = 2;\nconst NO_PADDING = 0 // zero-padding mode\n,\n      PAD_WITH_ZERO = 1;\nconst precisionConstants = {\n  ROUND,\n  TRUNCATE,\n  ROUND_UP,\n  ROUND_DOWN,\n  DECIMAL_PLACES,\n  SIGNIFICANT_DIGITS,\n  TICK_SIZE,\n  NO_PADDING,\n  PAD_WITH_ZERO\n};\n/*  ------------------------------------------------------------------------ */\n// See https://stackoverflow.com/questions/1685680/how-to-avoid-scientific-notation-for-large-numbers-in-javascript for discussion\n\nfunction numberToString(x) {\n  // avoids scientific notation for too large and too small numbers\n  if (typeof x === 'string') return x;\n  const s = x.toString();\n\n  if (Math.abs(x) < 1.0) {\n    const n_e = s.split('e-');\n    const n = n_e[0].replace('.', '');\n    const e = parseInt(n_e[1]);\n    const neg = s[0] === '-';\n\n    if (e) {\n      x = (neg ? '-' : '') + '0.' + new Array(e).join('0') + n.substring(neg);\n      return x;\n    }\n  } else {\n    const parts = s.split('e');\n\n    if (parts[1]) {\n      let e = parseInt(parts[1]);\n      const m = parts[0].split('.');\n\n      if (m[1]) {\n        e -= m[1].length;\n      }\n\n      return m[0] + m[1] + new Array(e + 1).join('0');\n    }\n  }\n\n  return s;\n} //-----------------------------------------------------------------------------\n// expects non-scientific notation\n\n\nconst truncate_regExpCache = [],\n      truncate_to_string = (num, precision = 0) => {\n  num = numberToString(num);\n\n  if (precision > 0) {\n    const re = truncate_regExpCache[precision] || (truncate_regExpCache[precision] = new RegExp(\"([-]*\\\\d+\\\\.\\\\d{\" + precision + \"})(\\\\d)\"));\n    const [, result] = num.toString().match(re) || [null, num];\n    return result.toString();\n  }\n\n  return parseInt(num).toString();\n},\n      truncate = (num, precision = 0) => parseFloat(truncate_to_string(num, precision));\n\nfunction precisionFromString(string) {\n  const split = string.replace(/0+$/g, '').split('.');\n  return split.length > 1 ? split[1].length : 0;\n}\n/*  ------------------------------------------------------------------------ */\n\n\nconst decimalToPrecision = (x, roundingMode, numPrecisionDigits, countingMode = DECIMAL_PLACES, paddingMode = NO_PADDING) => {\n  if (countingMode === TICK_SIZE) {\n    if (numPrecisionDigits <= 0) {\n      throw new Error('TICK_SIZE cant be used with negative or zero numPrecisionDigits');\n    }\n  }\n\n  if (numPrecisionDigits < 0) {\n    const toNearest = Math.pow(10, -numPrecisionDigits);\n\n    if (roundingMode === ROUND) {\n      return (toNearest * decimalToPrecision(x / toNearest, roundingMode, 0, countingMode, paddingMode)).toString();\n    }\n\n    if (roundingMode === TRUNCATE) {\n      return (x - x % toNearest).toString();\n    }\n  }\n  /*  handle tick size */\n\n\n  if (countingMode === TICK_SIZE) {\n    const precisionDigitsString = decimalToPrecision(numPrecisionDigits, ROUND, 22, DECIMAL_PLACES, NO_PADDING);\n    const newNumPrecisionDigits = precisionFromString(precisionDigitsString);\n    let missing = x % numPrecisionDigits; // See: https://github.com/ccxt/ccxt/pull/6486\n\n    missing = Number(decimalToPrecision(missing, ROUND, 8, DECIMAL_PLACES, NO_PADDING));\n    const fpError = decimalToPrecision(missing / numPrecisionDigits, ROUND, Math.max(newNumPrecisionDigits, 8), DECIMAL_PLACES, NO_PADDING);\n\n    if (precisionFromString(fpError) !== 0) {\n      if (roundingMode === ROUND) {\n        if (x > 0) {\n          if (missing >= numPrecisionDigits / 2) {\n            x = x - missing + numPrecisionDigits;\n          } else {\n            x = x - missing;\n          }\n        } else {\n          if (missing >= numPrecisionDigits / 2) {\n            x = Number(x) - missing;\n          } else {\n            x = Number(x) - missing - numPrecisionDigits;\n          }\n        }\n      } else if (roundingMode === TRUNCATE) {\n        x = x - missing;\n      }\n    }\n\n    return decimalToPrecision(x, ROUND, newNumPrecisionDigits, DECIMAL_PLACES, paddingMode);\n  }\n  /*  Convert to a string (if needed), skip leading minus sign (if any)   */\n\n\n  const str = numberToString(x),\n        isNegative = str[0] === '-',\n        strStart = isNegative ? 1 : 0,\n        strEnd = str.length;\n  /*  Find the dot position in the source buffer   */\n\n  for (var strDot = 0; strDot < strEnd; strDot++) if (str[strDot] === '.') break;\n\n  const hasDot = strDot < str.length;\n  /*  Char code constants         */\n\n  const MINUS = 45,\n        DOT = 46,\n        ZERO = 48,\n        ONE = ZERO + 1,\n        FIVE = ZERO + 5,\n        NINE = ZERO + 9;\n  /*  For -123.4567 the `chars` array will hold 01234567 (leading zero is reserved for rounding cases when 099 → 100)    */\n\n  const chars = new Uint8Array(strEnd - strStart + (hasDot ? 0 : 1));\n  chars[0] = ZERO;\n  /*  Validate & copy digits, determine certain locations in the resulting buffer  */\n\n  let afterDot = chars.length,\n      digitsStart = -1 // significant digits\n  ,\n      digitsEnd = -1;\n\n  for (var i = 1, j = strStart; j < strEnd; j++, i++) {\n    const c = str.charCodeAt(j);\n\n    if (c === DOT) {\n      afterDot = i--;\n    } else if (c < ZERO || c > NINE) {\n      throw new Error(`${str}: invalid number (contains an illegal character '${str[i - 1]}')`);\n    } else {\n      chars[i] = c;\n      if (c !== ZERO && digitsStart < 0) digitsStart = i;\n    }\n  }\n\n  if (digitsStart < 0) digitsStart = 1;\n  /*  Determine the range to cut  */\n\n  let precisionStart = countingMode === DECIMAL_PLACES ? afterDot // 0.(0)001234567\n  : digitsStart // 0.00(1)234567\n  ,\n      precisionEnd = precisionStart + numPrecisionDigits;\n  /*  Reset the last significant digit index, as it will change during the rounding/truncation.   */\n\n  digitsEnd = -1;\n  /*  Perform rounding/truncation per digit, from digitsEnd to digitsStart, by using the following\n      algorithm (rounding 999 → 1000, as an example):\n  \n          step  =          i=3      i=2      i=1      i=0\n  \n          chars =         0999     0999     0900     1000\n          memo  =         ---0     --1-     -1--     0---                     */\n\n  let allZeros = true;\n  let signNeeded = isNegative;\n\n  for (let i = chars.length - 1, memo = 0; i >= 0; i--) {\n    let c = chars[i];\n\n    if (i !== 0) {\n      c += memo;\n\n      if (i >= precisionStart + numPrecisionDigits) {\n        const ceil = roundingMode === ROUND && c >= FIVE && !(c === FIVE && memo); // prevents rounding of 1.45 to 2\n\n        c = ceil ? NINE + 1 : ZERO;\n      }\n\n      if (c > NINE) {\n        c = ZERO;\n        memo = 1;\n      } else memo = 0;\n    } else if (memo) c = ONE; // leading extra digit (0900 → 1000)\n\n\n    chars[i] = c;\n\n    if (c !== ZERO) {\n      allZeros = false;\n      digitsStart = i;\n      digitsEnd = digitsEnd < 0 ? i + 1 : digitsEnd;\n    }\n  }\n  /*  Update the precision range, as `digitsStart` may have changed... & the need for a negative sign if it is only 0    */\n\n\n  if (countingMode === SIGNIFICANT_DIGITS) {\n    precisionStart = digitsStart;\n    precisionEnd = precisionStart + numPrecisionDigits;\n  }\n\n  if (allZeros) {\n    signNeeded = false;\n  }\n  /*  Determine the input character range     */\n\n\n  const readStart = digitsStart >= afterDot || allZeros ? afterDot - 1 : digitsStart // 0.000(1)234  ----> (0).0001234\n  ,\n        readEnd = digitsEnd < afterDot ? afterDot : digitsEnd; // 12(3)000     ----> 123000( )\n\n  /*  Compute various sub-ranges       */\n\n  const nSign = signNeeded ? 1 : 0 // (-)123.456\n  ,\n        nBeforeDot = nSign + (afterDot - readStart) // (-123).456\n  ,\n        nAfterDot = Math.max(readEnd - afterDot, 0) // -123.(456)\n  ,\n        actualLength = readEnd - readStart // -(123.456)\n  ,\n        desiredLength = paddingMode === NO_PADDING ? actualLength : // -(123.456)\n  precisionEnd - readStart // -(123.456    )\n  ,\n        pad = Math.max(desiredLength - actualLength, 0) //  -123.456(    )\n  ,\n        padStart = nBeforeDot + 1 + nAfterDot //  -123.456( )\n  ,\n        padEnd = padStart + pad //  -123.456     ( )\n  ,\n        isInteger = nAfterDot + pad === 0; //  -123\n\n  /*  Fill the output buffer with characters    */\n\n  const out = new Uint8Array(nBeforeDot + (isInteger ? 0 : 1) + nAfterDot + pad); // ------------------------------------------------------------------------------------------ // ---------------------\n\n  if (signNeeded) out[0] = MINUS; // -     minus sign\n\n  for (i = nSign, j = readStart; i < nBeforeDot; i++, j++) out[i] = chars[j]; // 123   before dot\n\n\n  if (!isInteger) out[nBeforeDot] = DOT; // .     dot\n\n  for (i = nBeforeDot + 1, j = afterDot; i < padStart; i++, j++) out[i] = chars[j]; // 456   after dot\n\n\n  for (i = padStart; i < padEnd; i++) out[i] = ZERO; // 000   padding\n\n  /*  Build a string from the output buffer     */\n\n\n  return String.fromCharCode(...out);\n}; // toWei / fromWei\n\n\nfunction fromWei(amount, decimals = 18) {\n  if (amount === undefined) {\n    return amount;\n  }\n\n  const exponential = Math.floor(amount).toExponential(); // wei must be whole numbers\n\n  const [n, exponent] = exponential.split('e');\n  const newExponent = parseInt(exponent) - decimals;\n  return parseFloat(n + 'e' + newExponent);\n}\n\nfunction toWei(amount, decimals = 18) {\n  if (amount === undefined) {\n    return amount;\n  }\n\n  const exponential = parseFloat(amount).toExponential();\n  const [n, exponent] = exponential.split('e');\n  const newExponent = parseInt(exponent) + decimals;\n  return numberToString(Math.floor(parseFloat(n + 'e' + newExponent))); // wei must be whole numbers\n}\n/*  ------------------------------------------------------------------------ */\n\n\nmodule.exports = {\n  toWei,\n  fromWei,\n  numberToString,\n  precisionFromString,\n  decimalToPrecision,\n  truncate_to_string,\n  truncate,\n  precisionConstants,\n  ROUND,\n  TRUNCATE,\n  ROUND_UP,\n  ROUND_DOWN,\n  DECIMAL_PLACES,\n  SIGNIFICANT_DIGITS,\n  TICK_SIZE,\n  NO_PADDING,\n  PAD_WITH_ZERO\n};\n/*  ------------------------------------------------------------------------ */","map":{"version":3,"sources":["C:/Users/senya/Documents/Coding/React Projects/react-stock-ticker/node_modules/ccxt/js/base/functions/number.js"],"names":["ROUND","TRUNCATE","ROUND_UP","ROUND_DOWN","DECIMAL_PLACES","SIGNIFICANT_DIGITS","TICK_SIZE","NO_PADDING","PAD_WITH_ZERO","precisionConstants","numberToString","x","s","toString","Math","abs","n_e","split","n","replace","e","parseInt","neg","Array","join","substring","parts","m","length","truncate_regExpCache","truncate_to_string","num","precision","re","RegExp","result","match","truncate","parseFloat","precisionFromString","string","decimalToPrecision","roundingMode","numPrecisionDigits","countingMode","paddingMode","Error","toNearest","pow","precisionDigitsString","newNumPrecisionDigits","missing","Number","fpError","max","str","isNegative","strStart","strEnd","strDot","hasDot","MINUS","DOT","ZERO","ONE","FIVE","NINE","chars","Uint8Array","afterDot","digitsStart","digitsEnd","i","j","c","charCodeAt","precisionStart","precisionEnd","allZeros","signNeeded","memo","ceil","readStart","readEnd","nSign","nBeforeDot","nAfterDot","actualLength","desiredLength","pad","padStart","padEnd","isInteger","out","String","fromCharCode","fromWei","amount","decimals","undefined","exponential","floor","toExponential","exponent","newExponent","toWei","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/*  ------------------------------------------------------------------------\n\n    NB: initially, I used objects for options passing:\n\n            decimalToPrecision ('123.456', { digits: 2, round: true, afterPoint: true })\n\n    ...but it turns out it's hard to port that across different languages and it is also\n       probably has a performance penalty -- while it's a performance critical code! So\n       I switched to using named constants instead, as it is actually more readable and\n       succinct, and surely doesn't come with any inherent performance downside:\n\n            decimalToPrecision ('123.456', ROUND, 2, DECIMAL_PLACES)                     */\n\nconst ROUND      = 0                // rounding mode\n    , TRUNCATE   = 1\n    , ROUND_UP   = 2\n    , ROUND_DOWN = 3\n\nconst DECIMAL_PLACES     = 0        // digits counting mode\n    , SIGNIFICANT_DIGITS = 1\n    , TICK_SIZE = 2\n\nconst NO_PADDING    = 0             // zero-padding mode\n    , PAD_WITH_ZERO = 1\n\nconst precisionConstants = {\n    ROUND,\n    TRUNCATE,\n    ROUND_UP,\n    ROUND_DOWN,\n    DECIMAL_PLACES,\n    SIGNIFICANT_DIGITS,\n    TICK_SIZE,\n    NO_PADDING,\n    PAD_WITH_ZERO,\n}\n\n/*  ------------------------------------------------------------------------ */\n\n// See https://stackoverflow.com/questions/1685680/how-to-avoid-scientific-notation-for-large-numbers-in-javascript for discussion\n\nfunction numberToString (x) { // avoids scientific notation for too large and too small numbers\n\n    if (typeof x === 'string') return x\n\n    const s = x.toString ()\n    if (Math.abs (x) < 1.0) {\n        const n_e = s.split ('e-')\n        const n = n_e[0].replace ('.', '')\n        const e = parseInt (n_e[1])\n        const neg = (s[0] === '-')\n        if (e) {\n            x = (neg ? '-' : '') + '0.' + (new Array (e)).join ('0') + n.substring (neg)\n            return x\n        }\n    } else {\n        const parts = s.split ('e')\n        if (parts[1]) {\n            let e = parseInt (parts[1])\n            const m = parts[0].split ('.')\n            if (m[1]) {\n                e -= m[1].length\n            }\n            return m[0] + m[1] + (new Array (e + 1)).join ('0')\n        }\n    }\n    return s\n}\n\n//-----------------------------------------------------------------------------\n// expects non-scientific notation\n\nconst truncate_regExpCache = []\n    , truncate_to_string = (num, precision = 0) => {\n        num = numberToString (num)\n        if (precision > 0) {\n            const re = truncate_regExpCache[precision] || (truncate_regExpCache[precision] = new RegExp (\"([-]*\\\\d+\\\\.\\\\d{\" + precision + \"})(\\\\d)\"))\n            const [ , result] = num.toString ().match (re) || [null, num]\n            return result.toString ()\n        }\n        return parseInt (num).toString ()\n    }\n    , truncate = (num, precision = 0) => parseFloat (truncate_to_string (num, precision))\n\nfunction precisionFromString (string) {\n    const split = string.replace (/0+$/g, '').split ('.')\n    return (split.length > 1) ? (split[1].length) : 0\n}\n\n/*  ------------------------------------------------------------------------ */\n\nconst decimalToPrecision = (x, roundingMode\n                             , numPrecisionDigits\n                             , countingMode       = DECIMAL_PLACES\n                             , paddingMode        = NO_PADDING) => {\n\n    if (countingMode === TICK_SIZE) {\n        if (numPrecisionDigits <= 0) {\n            throw new Error ('TICK_SIZE cant be used with negative or zero numPrecisionDigits')\n        }\n    }\n\n    if (numPrecisionDigits < 0) {\n        const toNearest = Math.pow (10, -numPrecisionDigits)\n        if (roundingMode === ROUND) {\n            return (toNearest * decimalToPrecision (x / toNearest, roundingMode, 0, countingMode, paddingMode)).toString ()\n        }\n        if (roundingMode === TRUNCATE) {\n            return (x - (x % toNearest)).toString ()\n        }\n    }\n\n/*  handle tick size */\n    if (countingMode === TICK_SIZE) {\n        const precisionDigitsString = decimalToPrecision (numPrecisionDigits, ROUND, 22, DECIMAL_PLACES, NO_PADDING)\n        const newNumPrecisionDigits = precisionFromString (precisionDigitsString)\n        let missing = x % numPrecisionDigits\n        // See: https://github.com/ccxt/ccxt/pull/6486\n        missing = Number (decimalToPrecision (missing, ROUND, 8, DECIMAL_PLACES, NO_PADDING));\n        const fpError = decimalToPrecision (missing / numPrecisionDigits, ROUND, Math.max (newNumPrecisionDigits, 8), DECIMAL_PLACES, NO_PADDING)\n        if (precisionFromString (fpError) !== 0) {\n            if (roundingMode === ROUND) {\n                if (x > 0) {\n                    if (missing >= numPrecisionDigits / 2) {\n                        x = x - missing + numPrecisionDigits\n                    } else {\n                        x = x - missing\n                    }\n                } else {\n                    if (missing >= numPrecisionDigits / 2) {\n                        x = Number (x) - missing\n                    } else {\n                        x = Number (x) - missing - numPrecisionDigits\n                    }\n                }\n            } else if (roundingMode === TRUNCATE) {\n                x = x - missing\n            }\n        }\n        return decimalToPrecision (x, ROUND, newNumPrecisionDigits, DECIMAL_PLACES, paddingMode);\n    }\n\n/*  Convert to a string (if needed), skip leading minus sign (if any)   */\n\n    const str          = numberToString (x)\n        , isNegative   = str[0] === '-'\n        , strStart     = isNegative ? 1 : 0\n        , strEnd       = str.length\n\n/*  Find the dot position in the source buffer   */\n\n    for (var strDot = 0; strDot < strEnd; strDot++)\n        if (str[strDot] === '.')\n            break\n\n    const hasDot = strDot < str.length\n\n/*  Char code constants         */\n\n    const MINUS =  45\n        , DOT   =  46\n        , ZERO  =  48\n        , ONE   = (ZERO + 1)\n        , FIVE  = (ZERO + 5)\n        , NINE  = (ZERO + 9)\n\n/*  For -123.4567 the `chars` array will hold 01234567 (leading zero is reserved for rounding cases when 099 → 100)    */\n\n    const chars    = new Uint8Array ((strEnd - strStart) + (hasDot ? 0 : 1))\n          chars[0] = ZERO\n\n/*  Validate & copy digits, determine certain locations in the resulting buffer  */\n\n    let afterDot    = chars.length\n      , digitsStart = -1                // significant digits\n      , digitsEnd   = -1\n\n    for (var i = 1, j = strStart; j < strEnd; j++, i++) {\n\n        const c = str.charCodeAt (j)\n\n        if (c === DOT) {\n            afterDot = i--\n\n        } else if ((c < ZERO) || (c > NINE)) {\n            throw new Error (`${str}: invalid number (contains an illegal character '${str[i - 1]}')`)\n\n        } else {\n            chars[i] = c\n            if ((c !== ZERO) && (digitsStart < 0)) digitsStart = i\n        }\n    }\n\n    if (digitsStart < 0) digitsStart = 1\n\n/*  Determine the range to cut  */\n\n    let precisionStart = (countingMode === DECIMAL_PLACES) ? afterDot      // 0.(0)001234567\n                                                           : digitsStart   // 0.00(1)234567\n      , precisionEnd = precisionStart +\n                       numPrecisionDigits\n\n/*  Reset the last significant digit index, as it will change during the rounding/truncation.   */\n\n    digitsEnd = -1\n\n/*  Perform rounding/truncation per digit, from digitsEnd to digitsStart, by using the following\n    algorithm (rounding 999 → 1000, as an example):\n\n        step  =          i=3      i=2      i=1      i=0\n\n        chars =         0999     0999     0900     1000\n        memo  =         ---0     --1-     -1--     0---                     */\n\n    let allZeros = true;\n    let signNeeded = isNegative;\n\n    for (let i = chars.length - 1, memo = 0; i >= 0; i--) {\n\n        let c = chars[i]\n\n        if (i !== 0) {\n            c += memo\n\n            if (i >= (precisionStart + numPrecisionDigits)) {\n\n                const ceil = (roundingMode === ROUND) &&\n                             (c >= FIVE) &&\n                            !((c === FIVE) && memo) // prevents rounding of 1.45 to 2\n\n                c = ceil ? (NINE + 1) : ZERO\n            }\n            if (c > NINE) { c = ZERO; memo = 1; }\n            else memo = 0\n\n        } else if (memo) c = ONE // leading extra digit (0900 → 1000)\n\n        chars[i] = c\n\n        if (c !== ZERO) {\n            allZeros    = false\n            digitsStart = i\n            digitsEnd   = (digitsEnd < 0) ? (i + 1) : digitsEnd\n        }\n    }\n\n/*  Update the precision range, as `digitsStart` may have changed... & the need for a negative sign if it is only 0    */\n\n    if (countingMode === SIGNIFICANT_DIGITS) {\n        precisionStart = digitsStart\n        precisionEnd   = precisionStart + numPrecisionDigits\n    }\n\n    if (allZeros) {\n        signNeeded = false\n    }\n\n/*  Determine the input character range     */\n\n    const readStart     = ((digitsStart >= afterDot) || allZeros) ? (afterDot - 1) : digitsStart // 0.000(1)234  ----> (0).0001234\n        , readEnd       = (digitsEnd    < afterDot) ? (afterDot    ) : digitsEnd   // 12(3)000     ----> 123000( )\n\n/*  Compute various sub-ranges       */\n\n    const nSign         =          (signNeeded ? 1 : 0)                // (-)123.456\n        , nBeforeDot    =          (nSign + (afterDot - readStart))    // (-123).456\n        , nAfterDot     = Math.max (readEnd - afterDot, 0)             // -123.(456)\n        , actualLength  =          (readEnd - readStart)               // -(123.456)\n        , desiredLength =          (paddingMode === NO_PADDING)\n                                       ? (actualLength)                // -(123.456)\n                                       : (precisionEnd - readStart)    // -(123.456    )\n\n        , pad           = Math.max (desiredLength - actualLength, 0)   //  -123.456(    )\n        , padStart      =          (nBeforeDot + 1 + nAfterDot)        //  -123.456( )\n        , padEnd        =          (padStart + pad)                    //  -123.456     ( )\n        , isInteger     =          (nAfterDot + pad) === 0             //  -123\n\n/*  Fill the output buffer with characters    */\n\n    const out = new Uint8Array (nBeforeDot + (isInteger ? 0 : 1) + nAfterDot + pad)\n    // ------------------------------------------------------------------------------------------ // ---------------------\n    if  (signNeeded)                                                  out[0]          = MINUS     // -     minus sign\n    for (i = nSign, j = readStart;          i < nBeforeDot; i++, j++) out[i]          = chars[j]  // 123   before dot\n    if  (!isInteger)                                                  out[nBeforeDot] = DOT       // .     dot\n    for (i = nBeforeDot + 1, j = afterDot;  i < padStart;   i++, j++) out[i]          = chars[j]  // 456   after dot\n    for (i = padStart;                      i < padEnd;     i++)      out[i]          = ZERO      // 000   padding\n\n/*  Build a string from the output buffer     */\n\n    return String.fromCharCode (...out)\n}\n\n// toWei / fromWei\n\nfunction fromWei (amount, decimals = 18) {\n    if (amount === undefined) {\n        return amount\n    }\n    const exponential = Math.floor (amount).toExponential () // wei must be whole numbers\n    const [ n, exponent ] = exponential.split ('e')\n    const newExponent = parseInt (exponent) - decimals\n    return parseFloat (n + 'e' + newExponent)\n}\n\nfunction toWei (amount, decimals = 18) {\n    if (amount === undefined) {\n        return amount\n    }\n    const exponential = parseFloat (amount).toExponential ()\n    const [ n, exponent ] = exponential.split ('e')\n    const newExponent = parseInt (exponent) + decimals\n    return numberToString (Math.floor (parseFloat (n + 'e' + newExponent))) // wei must be whole numbers\n}\n\n/*  ------------------------------------------------------------------------ */\n\nmodule.exports = {\n    toWei,\n    fromWei,\n    numberToString,\n    precisionFromString,\n    decimalToPrecision,\n    truncate_to_string,\n    truncate,\n    precisionConstants,\n    ROUND,\n    TRUNCATE,\n    ROUND_UP,\n    ROUND_DOWN,\n    DECIMAL_PLACES,\n    SIGNIFICANT_DIGITS,\n    TICK_SIZE,\n    NO_PADDING,\n    PAD_WITH_ZERO,\n}\n\n/*  ------------------------------------------------------------------------ */\n"]},"metadata":{},"sourceType":"script"}