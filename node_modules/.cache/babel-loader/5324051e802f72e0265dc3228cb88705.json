{"ast":null,"code":"'use strict';\n\nconst Exchange = require('./base/Exchange');\n\nconst {\n  ExchangeError,\n  ArgumentsRequired,\n  ExchangeNotAvailable,\n  InsufficientFunds,\n  OrderNotFound,\n  DDoSProtection,\n  InvalidOrder,\n  AuthenticationError\n} = require('./base/errors');\n\nmodule.exports = class tidex extends Exchange {\n  describe() {\n    return this.deepExtend(super.describe(), {\n      'id': 'tidex',\n      'name': 'Tidex',\n      'countries': ['UK'],\n      'rateLimit': 2000,\n      'version': '3',\n      'userAgent': this.userAgents['chrome'],\n      'has': {\n        'cancelOrder': true,\n        'CORS': false,\n        'createMarketOrder': false,\n        'createOrder': true,\n        'fetchBalance': true,\n        'fetchCurrencies': true,\n        'fetchMarkets': true,\n        'fetchMyTrades': true,\n        'fetchOpenOrders': true,\n        'fetchOrder': true,\n        'fetchOrderBook': true,\n        'fetchOrderBooks': true,\n        'fetchTicker': true,\n        'fetchTickers': true,\n        'fetchTrades': true,\n        'withdraw': true\n      },\n      'urls': {\n        'logo': 'https://user-images.githubusercontent.com/1294454/30781780-03149dc4-a12e-11e7-82bb-313b269d24d4.jpg',\n        'api': {\n          'web': 'https://gate.tidex.com/api',\n          'public': 'https://api.tidex.com/api/3',\n          'private': 'https://api.tidex.com/tapi'\n        },\n        'www': 'https://tidex.com',\n        'doc': 'https://tidex.com/exchange/public-api',\n        'referral': 'https://tidex.com/exchange/?ref=57f5638d9cd7',\n        'fees': ['https://tidex.com/exchange/assets-spec', 'https://tidex.com/exchange/pairs-spec']\n      },\n      'api': {\n        'web': {\n          'get': ['currency', 'pairs', 'tickers', 'orders', 'ordershistory', 'trade-data', 'trade-data/{id}']\n        },\n        'public': {\n          'get': ['info', 'ticker/{pair}', 'depth/{pair}', 'trades/{pair}']\n        },\n        'private': {\n          'post': ['getInfoExt', 'getInfo', 'Trade', 'ActiveOrders', 'OrderInfo', 'CancelOrder', 'TradeHistory', 'CoinDepositAddress', 'WithdrawCoin', 'CreateCoupon', 'RedeemCoupon']\n        }\n      },\n      'fees': {\n        'trading': {\n          'tierBased': false,\n          'percentage': true,\n          'taker': 0.1 / 100,\n          'maker': 0.1 / 100\n        }\n      },\n      'commonCurrencies': {\n        'DSH': 'DASH',\n        'EMGO': 'MGO',\n        'MGO': 'WMGO'\n      },\n      'exceptions': {\n        'exact': {\n          '803': InvalidOrder,\n          // \"Count could not be less than 0.001.\" (selling below minAmount)\n          '804': InvalidOrder,\n          // \"Count could not be more than 10000.\" (buying above maxAmount)\n          '805': InvalidOrder,\n          // \"price could not be less than X.\" (minPrice violation on buy & sell)\n          '806': InvalidOrder,\n          // \"price could not be more than X.\" (maxPrice violation on buy & sell)\n          '807': InvalidOrder,\n          // \"cost could not be less than X.\" (minCost violation on buy & sell)\n          '831': InsufficientFunds,\n          // \"Not enougth X to create buy order.\" (buying with balance.quote < order.cost)\n          '832': InsufficientFunds,\n          // \"Not enougth X to create sell order.\" (selling with balance.base < order.amount)\n          '833': OrderNotFound // \"Order with id X was not found.\" (cancelling non-existent, closed and cancelled order)\n\n        },\n        'broad': {\n          'Invalid pair name': ExchangeError,\n          // {\"success\":0,\"error\":\"Invalid pair name: btc_eth\"}\n          'invalid api key': AuthenticationError,\n          'invalid sign': AuthenticationError,\n          'api key dont have trade permission': AuthenticationError,\n          'invalid parameter': InvalidOrder,\n          'invalid order': InvalidOrder,\n          'Requests too often': DDoSProtection,\n          'not available': ExchangeNotAvailable,\n          'data unavailable': ExchangeNotAvailable,\n          'external service unavailable': ExchangeNotAvailable\n        }\n      },\n      'options': {\n        'fetchTickersMaxLength': 2048\n      },\n      'orders': {} // orders cache / emulation\n\n    });\n  }\n\n  async fetchCurrencies(params = {}) {\n    const response = await this.webGetCurrency(params);\n    const result = {};\n\n    for (let i = 0; i < response.length; i++) {\n      const currency = response[i];\n      const id = this.safeString(currency, 'symbol');\n      const precision = currency['amountPoint'];\n      const code = this.safeCurrencyCode(id);\n      let active = currency['visible'] === true;\n      const canWithdraw = currency['withdrawEnable'] === true;\n      const canDeposit = currency['depositEnable'] === true;\n\n      if (!canWithdraw || !canDeposit) {\n        active = false;\n      }\n\n      const name = this.safeString(currency, 'name');\n      result[code] = {\n        'id': id,\n        'code': code,\n        'name': name,\n        'active': active,\n        'precision': precision,\n        'funding': {\n          'withdraw': {\n            'active': canWithdraw,\n            'fee': currency['withdrawFee']\n          },\n          'deposit': {\n            'active': canDeposit,\n            'fee': 0.0\n          }\n        },\n        'limits': {\n          'amount': {\n            'min': undefined,\n            'max': Math.pow(10, precision)\n          },\n          'price': {\n            'min': Math.pow(10, -precision),\n            'max': Math.pow(10, precision)\n          },\n          'cost': {\n            'min': undefined,\n            'max': undefined\n          },\n          'withdraw': {\n            'min': this.safeFloat(currency, 'withdrawMinAmount'),\n            'max': undefined\n          },\n          'deposit': {\n            'min': this.safeFloat(currency, 'depositMinAmount'),\n            'max': undefined\n          }\n        },\n        'info': currency\n      };\n    }\n\n    return result;\n  }\n\n  calculateFee(symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {\n    const market = this.markets[symbol];\n    let key = 'quote';\n    const rate = market[takerOrMaker];\n    let cost = parseFloat(this.costToPrecision(symbol, amount * rate));\n\n    if (side === 'sell') {\n      cost *= price;\n    } else {\n      key = 'base';\n    }\n\n    return {\n      'type': takerOrMaker,\n      'currency': market[key],\n      'rate': rate,\n      'cost': cost\n    };\n  }\n\n  async fetchMarkets(params = {}) {\n    const response = await this.publicGetInfo(params);\n    const markets = response['pairs'];\n    const keys = Object.keys(markets);\n    const result = [];\n\n    for (let i = 0; i < keys.length; i++) {\n      const id = keys[i];\n      const market = markets[id];\n      const [baseId, quoteId] = id.split('_');\n      const base = this.safeCurrencyCode(baseId);\n      const quote = this.safeCurrencyCode(quoteId);\n      const symbol = base + '/' + quote;\n      const precision = {\n        'amount': this.safeInteger(market, 'decimal_places'),\n        'price': this.safeInteger(market, 'decimal_places')\n      };\n      const limits = {\n        'amount': {\n          'min': this.safeFloat(market, 'min_amount'),\n          'max': this.safeFloat(market, 'max_amount')\n        },\n        'price': {\n          'min': this.safeFloat(market, 'min_price'),\n          'max': this.safeFloat(market, 'max_price')\n        },\n        'cost': {\n          'min': this.safeFloat(market, 'min_total')\n        }\n      };\n      const hidden = this.safeInteger(market, 'hidden');\n      const active = hidden === 0;\n      result.push({\n        'id': id,\n        'symbol': symbol,\n        'base': base,\n        'quote': quote,\n        'baseId': baseId,\n        'quoteId': quoteId,\n        'active': active,\n        'taker': market['fee'] / 100,\n        'precision': precision,\n        'limits': limits,\n        'info': market\n      });\n    }\n\n    return result;\n  }\n\n  async fetchBalance(params = {}) {\n    await this.loadMarkets();\n    const response = await this.privatePostGetInfoExt(params);\n    const balances = this.safeValue(response, 'return');\n    const result = {\n      'info': balances\n    };\n    const funds = this.safeValue(balances, 'funds', {});\n    const currencyIds = Object.keys(funds);\n\n    for (let i = 0; i < currencyIds.length; i++) {\n      const currencyId = currencyIds[i];\n      const code = this.safeCurrencyCode(currencyId);\n      const balance = this.safeValue(funds, currencyId, {});\n      const account = this.account();\n      account['free'] = this.safeFloat(balance, 'value');\n      account['used'] = this.safeFloat(balance, 'inOrders');\n      result[code] = account;\n    }\n\n    return this.parseBalance(result);\n  }\n\n  async fetchOrderBook(symbol, limit = undefined, params = {}) {\n    await this.loadMarkets();\n    const market = this.market(symbol);\n    const request = {\n      'pair': market['id']\n    };\n\n    if (limit !== undefined) {\n      request['limit'] = limit; // default = 150, max = 2000\n    }\n\n    const response = await this.publicGetDepthPair(this.extend(request, params));\n    const market_id_in_reponse = (market['id'] in response);\n\n    if (!market_id_in_reponse) {\n      throw new ExchangeError(this.id + ' ' + market['symbol'] + ' order book is empty or not available');\n    }\n\n    const orderbook = response[market['id']];\n    return this.parseOrderBook(orderbook);\n  }\n\n  async fetchOrderBooks(symbols = undefined, limit = undefined, params = {}) {\n    await this.loadMarkets();\n    let ids = undefined;\n\n    if (symbols === undefined) {\n      ids = this.ids.join('-'); // max URL length is 2083 symbols, including http schema, hostname, tld, etc...\n\n      if (ids.length > 2048) {\n        const numIds = this.ids.length;\n        throw new ExchangeError(this.id + ' has ' + numIds.toString() + ' symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks');\n      }\n    } else {\n      ids = this.marketIds(symbols);\n      ids = ids.join('-');\n    }\n\n    const request = {\n      'pair': ids\n    };\n\n    if (limit !== undefined) {\n      request['limit'] = limit; // default = 150, max = 2000\n    }\n\n    const response = await this.publicGetDepthPair(this.extend(request, params));\n    const result = {};\n    ids = Object.keys(response);\n\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const symbol = this.safeSymbol(id);\n      result[symbol] = this.parseOrderBook(response[id]);\n    }\n\n    return result;\n  }\n\n  parseTicker(ticker, market = undefined) {\n    //\n    //   {    high: 0.03497582,\n    //         low: 0.03248474,\n    //         avg: 0.03373028,\n    //         vol: 120.11485715062999,\n    //     vol_cur: 3572.24914074,\n    //        last: 0.0337611,\n    //         buy: 0.0337442,\n    //        sell: 0.03377798,\n    //     updated: 1537522009          }\n    //\n    let timestamp = this.safeTimestamp(ticker, 'updated');\n    let symbol = undefined;\n\n    if (market !== undefined) {\n      symbol = market['symbol'];\n\n      if (!market['active']) {\n        timestamp = undefined;\n      }\n    }\n\n    const last = this.safeFloat(ticker, 'last');\n    return {\n      'symbol': symbol,\n      'timestamp': timestamp,\n      'datetime': this.iso8601(timestamp),\n      'high': this.safeFloat(ticker, 'high'),\n      'low': this.safeFloat(ticker, 'low'),\n      'bid': this.safeFloat(ticker, 'buy'),\n      'bidVolume': undefined,\n      'ask': this.safeFloat(ticker, 'sell'),\n      'askVolume': undefined,\n      'vwap': undefined,\n      'open': undefined,\n      'close': last,\n      'last': last,\n      'previousClose': undefined,\n      'change': undefined,\n      'percentage': undefined,\n      'average': this.safeFloat(ticker, 'avg'),\n      'baseVolume': this.safeFloat(ticker, 'vol_cur'),\n      'quoteVolume': this.safeFloat(ticker, 'vol'),\n      'info': ticker\n    };\n  }\n\n  async fetchTickers(symbols = undefined, params = {}) {\n    await this.loadMarkets();\n    let ids = this.ids;\n\n    if (symbols === undefined) {\n      const numIds = ids.length;\n      ids = ids.join('-'); // max URL length is 2048 symbols, including http schema, hostname, tld, etc...\n\n      if (ids.length > this.options['fetchTickersMaxLength']) {\n        const maxLength = this.safeInteger(this.options, 'fetchTickersMaxLength', 2048);\n        throw new ArgumentsRequired(this.id + ' has ' + numIds.toString() + ' markets exceeding max URL length for this endpoint (' + maxLength.toString() + ' characters), please, specify a list of symbols of interest in the first argument to fetchTickers');\n      }\n    } else {\n      ids = this.marketIds(symbols);\n      ids = ids.join('-');\n    }\n\n    const request = {\n      'pair': ids\n    };\n    const response = await this.publicGetTickerPair(this.extend(request, params));\n    const result = {};\n    const keys = Object.keys(response);\n\n    for (let i = 0; i < keys.length; i++) {\n      const id = keys[i];\n      const market = this.safeMarket(id);\n      const symbol = market['symbol'];\n      result[symbol] = this.parseTicker(response[id], market);\n    }\n\n    return this.filterByArray(result, 'symbol', symbols);\n  }\n\n  async fetchTicker(symbol, params = {}) {\n    const tickers = await this.fetchTickers([symbol], params);\n    return tickers[symbol];\n  }\n\n  parseTrade(trade, market = undefined) {\n    const timestamp = this.safeTimestamp(trade, 'timestamp');\n    let side = this.safeString(trade, 'type');\n\n    if (side === 'ask') {\n      side = 'sell';\n    } else if (side === 'bid') {\n      side = 'buy';\n    }\n\n    const price = this.safeFloat2(trade, 'rate', 'price');\n    const id = this.safeString2(trade, 'trade_id', 'tid');\n    const orderId = this.safeString(trade, 'order_id');\n    const marketId = this.safeString(trade, 'pair');\n    const symbol = this.safeSymbol(marketId, market);\n    const amount = this.safeFloat(trade, 'amount');\n    const type = 'limit'; // all trades are still limit trades\n\n    let takerOrMaker = undefined;\n    let fee = undefined;\n    const feeCost = this.safeFloat(trade, 'commission');\n\n    if (feeCost !== undefined) {\n      const feeCurrencyId = this.safeString(trade, 'commissionCurrency');\n      const feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);\n      fee = {\n        'cost': feeCost,\n        'currency': feeCurrencyCode\n      };\n    }\n\n    const isYourOrder = this.safeValue(trade, 'is_your_order');\n\n    if (isYourOrder !== undefined) {\n      takerOrMaker = 'taker';\n\n      if (isYourOrder) {\n        takerOrMaker = 'maker';\n      }\n\n      if (fee === undefined) {\n        fee = this.calculateFee(symbol, type, side, amount, price, takerOrMaker);\n      }\n    }\n\n    let cost = undefined;\n\n    if (amount !== undefined) {\n      if (price !== undefined) {\n        cost = amount * price;\n      }\n    }\n\n    return {\n      'id': id,\n      'order': orderId,\n      'timestamp': timestamp,\n      'datetime': this.iso8601(timestamp),\n      'symbol': symbol,\n      'type': type,\n      'side': side,\n      'takerOrMaker': takerOrMaker,\n      'price': price,\n      'amount': amount,\n      'cost': cost,\n      'fee': fee,\n      'info': trade\n    };\n  }\n\n  async fetchTrades(symbol, since = undefined, limit = undefined, params = {}) {\n    await this.loadMarkets();\n    const market = this.market(symbol);\n    const request = {\n      'pair': market['id']\n    };\n\n    if (limit !== undefined) {\n      request['limit'] = limit;\n    }\n\n    const response = await this.publicGetTradesPair(this.extend(request, params));\n\n    if (Array.isArray(response)) {\n      const numElements = response.length;\n\n      if (numElements === 0) {\n        return [];\n      }\n    }\n\n    return this.parseTrades(response[market['id']], market, since, limit);\n  }\n\n  async createOrder(symbol, type, side, amount, price = undefined, params = {}) {\n    if (type === 'market') {\n      throw new ExchangeError(this.id + ' allows limit orders only');\n    }\n\n    await this.loadMarkets();\n    const market = this.market(symbol);\n    const request = {\n      'pair': market['id'],\n      'type': side,\n      'amount': this.amountToPrecision(symbol, amount),\n      'rate': this.priceToPrecision(symbol, price)\n    };\n    price = parseFloat(price);\n    amount = parseFloat(amount);\n    const response = await this.privatePostTrade(this.extend(request, params));\n    let id = undefined;\n    let status = 'open';\n    let filled = 0.0;\n    let remaining = amount;\n\n    if ('return' in response) {\n      id = this.safeString(response['return'], 'order_id');\n\n      if (id === '0') {\n        id = this.safeString(response['return'], 'init_order_id');\n        status = 'closed';\n      }\n\n      filled = this.safeFloat(response['return'], 'received', 0.0);\n      remaining = this.safeFloat(response['return'], 'remains', amount);\n    }\n\n    const timestamp = this.milliseconds();\n    return {\n      'id': id,\n      'timestamp': timestamp,\n      'datetime': this.iso8601(timestamp),\n      'lastTradeTimestamp': undefined,\n      'status': status,\n      'symbol': symbol,\n      'type': type,\n      'side': side,\n      'price': price,\n      'cost': price * filled,\n      'amount': amount,\n      'remaining': remaining,\n      'filled': filled,\n      'fee': undefined,\n      // 'trades': this.parseTrades (order['trades'], market),\n      'info': response,\n      'clientOrderId': undefined,\n      'average': undefined,\n      'trades': undefined\n    };\n  }\n\n  async cancelOrder(id, symbol = undefined, params = {}) {\n    await this.loadMarkets();\n    const request = {\n      'order_id': parseInt(id)\n    };\n    return await this.privatePostCancelOrder(this.extend(request, params));\n  }\n\n  parseOrderStatus(status) {\n    const statuses = {\n      '0': 'open',\n      '1': 'closed',\n      '2': 'canceled',\n      '3': 'canceled' // or partially-filled and still open? https://github.com/ccxt/ccxt/issues/1594\n\n    };\n    return this.safeString(statuses, status, status);\n  }\n\n  parseOrder(order, market = undefined) {\n    const id = this.safeString(order, 'id');\n    const status = this.parseOrderStatus(this.safeString(order, 'status'));\n    const timestamp = this.safeTimestamp(order, 'timestamp_created');\n    const marketId = this.safeString(order, 'pair');\n    const symbol = this.safeSymbol(marketId, market);\n    let remaining = undefined;\n    let amount = undefined;\n    const price = this.safeFloat(order, 'rate');\n    let filled = undefined;\n    let cost = undefined;\n\n    if ('start_amount' in order) {\n      amount = this.safeFloat(order, 'start_amount');\n      remaining = this.safeFloat(order, 'amount');\n    } else {\n      remaining = this.safeFloat(order, 'amount');\n    }\n\n    if (amount !== undefined) {\n      if (remaining !== undefined) {\n        filled = amount - remaining;\n        cost = price * filled;\n      }\n    }\n\n    const fee = undefined;\n    return {\n      'info': order,\n      'id': id,\n      'clientOrderId': undefined,\n      'symbol': symbol,\n      'timestamp': timestamp,\n      'datetime': this.iso8601(timestamp),\n      'lastTradeTimestamp': undefined,\n      'type': 'limit',\n      'timeInForce': undefined,\n      'postOnly': undefined,\n      'side': this.safeString(order, 'type'),\n      'price': price,\n      'stopPrice': undefined,\n      'cost': cost,\n      'amount': amount,\n      'remaining': remaining,\n      'filled': filled,\n      'status': status,\n      'fee': fee,\n      'average': undefined,\n      'trades': undefined\n    };\n  }\n\n  async fetchOrder(id, symbol = undefined, params = {}) {\n    await this.loadMarkets();\n    const request = {\n      'order_id': parseInt(id)\n    };\n    const response = await this.privatePostOrderInfo(this.extend(request, params));\n    id = id.toString();\n    const result = this.safeValue(response, 'return', {});\n    const order = this.safeValue(result, id);\n    return this.parseOrder(this.extend({\n      'id': id\n    }, order));\n  }\n\n  async fetchOpenOrders(symbol = undefined, since = undefined, limit = undefined, params = {}) {\n    await this.loadMarkets();\n    const request = {};\n    let market = undefined;\n\n    if (symbol !== undefined) {\n      market = this.market(symbol);\n      request['pair'] = market['id'];\n    }\n\n    const response = await this.privatePostActiveOrders(this.extend(request, params)); //\n    //     {\n    //         \"success\":1,\n    //         \"return\":{\n    //             \"1255468911\":{\n    //                 \"status\":0,\n    //                 \"pair\":\"spike_usdt\",\n    //                 \"type\":\"sell\",\n    //                 \"amount\":35028.44256388,\n    //                 \"rate\":0.00199989,\n    //                 \"timestamp_created\":1602684432\n    //             }\n    //         },\n    //         \"stat\":{\n    //             \"isSuccess\":true,\n    //             \"serverTime\":\"00:00:00.0000826\",\n    //             \"time\":\"00:00:00.0091423\",\n    //             \"errors\":null\n    //         }\n    //     }\n    //\n    // it can only return 'open' orders (i.e. no way to fetch 'closed' orders)\n\n    const orders = this.safeValue(response, 'return', []);\n    return this.parseOrders(orders, market, since, limit);\n  }\n\n  async fetchMyTrades(symbol = undefined, since = undefined, limit = undefined, params = {}) {\n    await this.loadMarkets();\n    let market = undefined; // some derived classes use camelcase notation for request fields\n\n    const request = {// 'from': 123456789, // trade ID, from which the display starts numerical 0 (test result: liqui ignores this field)\n      // 'count': 1000, // the number of trades for display numerical, default = 1000\n      // 'from_id': trade ID, from which the display starts numerical 0\n      // 'end_id': trade ID on which the display ends numerical ∞\n      // 'order': 'ASC', // sorting, default = DESC (test result: liqui ignores this field, most recent trade always goes last)\n      // 'since': 1234567890, // UTC start time, default = 0 (test result: liqui ignores this field)\n      // 'end': 1234567890, // UTC end time, default = ∞ (test result: liqui ignores this field)\n      // 'pair': 'eth_btc', // default = all markets\n    };\n\n    if (symbol !== undefined) {\n      market = this.market(symbol);\n      request['pair'] = market['id'];\n    }\n\n    if (limit !== undefined) {\n      request['count'] = parseInt(limit);\n    }\n\n    if (since !== undefined) {\n      request['since'] = parseInt(since / 1000);\n    }\n\n    const response = await this.privatePostTradeHistory(this.extend(request, params));\n    const trades = this.safeValue(response, 'return', []);\n    return this.parseTrades(trades, market, since, limit);\n  }\n\n  async withdraw(code, amount, address, tag = undefined, params = {}) {\n    this.checkAddress(address);\n    await this.loadMarkets();\n    const currency = this.currency(code);\n    const request = {\n      'coinName': currency['id'],\n      'amount': parseFloat(amount),\n      'address': address\n    }; // no docs on the tag, yet...\n\n    if (tag !== undefined) {\n      throw new ExchangeError(this.id + ' withdraw() does not support the tag argument yet due to a lack of docs on withdrawing with tag/memo on behalf of the exchange.');\n    }\n\n    const response = await this.privatePostWithdrawCoin(this.extend(request, params));\n    return {\n      'info': response,\n      'id': response['return']['tId']\n    };\n  }\n\n  sign(path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {\n    let url = this.urls['api'][api];\n    const query = this.omit(params, this.extractParams(path));\n\n    if (api === 'private') {\n      this.checkRequiredCredentials();\n      const nonce = this.nonce();\n      body = this.urlencode(this.extend({\n        'nonce': nonce,\n        'method': path\n      }, query));\n      const signature = this.hmac(this.encode(body), this.encode(this.secret), 'sha512');\n      headers = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Key': this.apiKey,\n        'Sign': signature\n      };\n    } else if (api === 'public') {\n      url += '/' + this.implodeParams(path, params);\n\n      if (Object.keys(query).length) {\n        url += '?' + this.urlencode(query);\n      }\n    } else {\n      url += '/' + this.implodeParams(path, params);\n\n      if (method === 'GET') {\n        if (Object.keys(query).length) {\n          url += '?' + this.urlencode(query);\n        }\n      } else {\n        if (Object.keys(query).length) {\n          body = this.json(query);\n          headers = {\n            'Content-Type': 'application/json'\n          };\n        }\n      }\n    }\n\n    return {\n      'url': url,\n      'method': method,\n      'body': body,\n      'headers': headers\n    };\n  }\n\n  handleErrors(httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {\n    if (response === undefined) {\n      return; // fallback to default error handler\n    }\n\n    if ('success' in response) {\n      //\n      // 1 - The exchange only returns the integer 'success' key from their private API\n      //\n      //     { \"success\": 1, ... } httpCode === 200\n      //     { \"success\": 0, ... } httpCode === 200\n      //\n      // 2 - However, derived exchanges can return non-integers\n      //\n      //     It can be a numeric string\n      //     { \"sucesss\": \"1\", ... }\n      //     { \"sucesss\": \"0\", ... }, httpCode >= 200 (can be 403, 502, etc)\n      //\n      //     Or just a string\n      //     { \"success\": \"true\", ... }\n      //     { \"success\": \"false\", ... }, httpCode >= 200\n      //\n      //     Or a boolean\n      //     { \"success\": true, ... }\n      //     { \"success\": false, ... }, httpCode >= 200\n      //\n      // 3 - Oversimplified, Python PEP8 forbids comparison operator (===) of different types\n      //\n      // 4 - We do not want to copy-paste and duplicate the code of this handler to other exchanges derived from Liqui\n      //\n      // To cover points 1, 2, 3 and 4 combined this handler should work like this:\n      //\n      let success = this.safeValue(response, 'success', false);\n\n      if (typeof success === 'string') {\n        if (success === 'true' || success === '1') {\n          success = true;\n        } else {\n          success = false;\n        }\n      }\n\n      if (!success) {\n        const code = this.safeString(response, 'code');\n        const message = this.safeString(response, 'error');\n        const feedback = this.id + ' ' + body;\n        this.throwExactlyMatchedException(this.exceptions['exact'], code, feedback);\n        this.throwExactlyMatchedException(this.exceptions['exact'], message, feedback);\n        this.throwBroadlyMatchedException(this.exceptions['broad'], message, feedback);\n        throw new ExchangeError(feedback); // unknown message\n      }\n    }\n  }\n\n};","map":{"version":3,"sources":["C:/Users/senya/Documents/Coding/React Projects/react-stock-ticker/node_modules/ccxt/js/tidex.js"],"names":["Exchange","require","ExchangeError","ArgumentsRequired","ExchangeNotAvailable","InsufficientFunds","OrderNotFound","DDoSProtection","InvalidOrder","AuthenticationError","module","exports","tidex","describe","deepExtend","userAgents","fetchCurrencies","params","response","webGetCurrency","result","i","length","currency","id","safeString","precision","code","safeCurrencyCode","active","canWithdraw","canDeposit","name","undefined","Math","pow","safeFloat","calculateFee","symbol","type","side","amount","price","takerOrMaker","market","markets","key","rate","cost","parseFloat","costToPrecision","fetchMarkets","publicGetInfo","keys","Object","baseId","quoteId","split","base","quote","safeInteger","limits","hidden","push","fetchBalance","loadMarkets","privatePostGetInfoExt","balances","safeValue","funds","currencyIds","currencyId","balance","account","parseBalance","fetchOrderBook","limit","request","publicGetDepthPair","extend","market_id_in_reponse","orderbook","parseOrderBook","fetchOrderBooks","symbols","ids","join","numIds","toString","marketIds","safeSymbol","parseTicker","ticker","timestamp","safeTimestamp","last","iso8601","fetchTickers","options","maxLength","publicGetTickerPair","safeMarket","filterByArray","fetchTicker","tickers","parseTrade","trade","safeFloat2","safeString2","orderId","marketId","fee","feeCost","feeCurrencyId","feeCurrencyCode","isYourOrder","fetchTrades","since","publicGetTradesPair","Array","isArray","numElements","parseTrades","createOrder","amountToPrecision","priceToPrecision","privatePostTrade","status","filled","remaining","milliseconds","cancelOrder","parseInt","privatePostCancelOrder","parseOrderStatus","statuses","parseOrder","order","fetchOrder","privatePostOrderInfo","fetchOpenOrders","privatePostActiveOrders","orders","parseOrders","fetchMyTrades","privatePostTradeHistory","trades","withdraw","address","tag","checkAddress","privatePostWithdrawCoin","sign","path","api","method","headers","body","url","urls","query","omit","extractParams","checkRequiredCredentials","nonce","urlencode","signature","hmac","encode","secret","apiKey","implodeParams","json","handleErrors","httpCode","reason","requestHeaders","requestBody","success","message","feedback","throwExactlyMatchedException","exceptions","throwBroadlyMatchedException"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Exchange = require ('./base/Exchange');\nconst { ExchangeError, ArgumentsRequired, ExchangeNotAvailable, InsufficientFunds, OrderNotFound, DDoSProtection, InvalidOrder, AuthenticationError } = require ('./base/errors');\n\nmodule.exports = class tidex extends Exchange {\n    describe () {\n        return this.deepExtend (super.describe (), {\n            'id': 'tidex',\n            'name': 'Tidex',\n            'countries': [ 'UK' ],\n            'rateLimit': 2000,\n            'version': '3',\n            'userAgent': this.userAgents['chrome'],\n            'has': {\n                'cancelOrder': true,\n                'CORS': false,\n                'createMarketOrder': false,\n                'createOrder': true,\n                'fetchBalance': true,\n                'fetchCurrencies': true,\n                'fetchMarkets': true,\n                'fetchMyTrades': true,\n                'fetchOpenOrders': true,\n                'fetchOrder': true,\n                'fetchOrderBook': true,\n                'fetchOrderBooks': true,\n                'fetchTicker': true,\n                'fetchTickers': true,\n                'fetchTrades': true,\n                'withdraw': true,\n            },\n            'urls': {\n                'logo': 'https://user-images.githubusercontent.com/1294454/30781780-03149dc4-a12e-11e7-82bb-313b269d24d4.jpg',\n                'api': {\n                    'web': 'https://gate.tidex.com/api',\n                    'public': 'https://api.tidex.com/api/3',\n                    'private': 'https://api.tidex.com/tapi',\n                },\n                'www': 'https://tidex.com',\n                'doc': 'https://tidex.com/exchange/public-api',\n                'referral': 'https://tidex.com/exchange/?ref=57f5638d9cd7',\n                'fees': [\n                    'https://tidex.com/exchange/assets-spec',\n                    'https://tidex.com/exchange/pairs-spec',\n                ],\n            },\n            'api': {\n                'web': {\n                    'get': [\n                        'currency',\n                        'pairs',\n                        'tickers',\n                        'orders',\n                        'ordershistory',\n                        'trade-data',\n                        'trade-data/{id}',\n                    ],\n                },\n                'public': {\n                    'get': [\n                        'info',\n                        'ticker/{pair}',\n                        'depth/{pair}',\n                        'trades/{pair}',\n                    ],\n                },\n                'private': {\n                    'post': [\n                        'getInfoExt',\n                        'getInfo',\n                        'Trade',\n                        'ActiveOrders',\n                        'OrderInfo',\n                        'CancelOrder',\n                        'TradeHistory',\n                        'CoinDepositAddress',\n                        'WithdrawCoin',\n                        'CreateCoupon',\n                        'RedeemCoupon',\n                    ],\n                },\n            },\n            'fees': {\n                'trading': {\n                    'tierBased': false,\n                    'percentage': true,\n                    'taker': 0.1 / 100,\n                    'maker': 0.1 / 100,\n                },\n            },\n            'commonCurrencies': {\n                'DSH': 'DASH',\n                'EMGO': 'MGO',\n                'MGO': 'WMGO',\n            },\n            'exceptions': {\n                'exact': {\n                    '803': InvalidOrder, // \"Count could not be less than 0.001.\" (selling below minAmount)\n                    '804': InvalidOrder, // \"Count could not be more than 10000.\" (buying above maxAmount)\n                    '805': InvalidOrder, // \"price could not be less than X.\" (minPrice violation on buy & sell)\n                    '806': InvalidOrder, // \"price could not be more than X.\" (maxPrice violation on buy & sell)\n                    '807': InvalidOrder, // \"cost could not be less than X.\" (minCost violation on buy & sell)\n                    '831': InsufficientFunds, // \"Not enougth X to create buy order.\" (buying with balance.quote < order.cost)\n                    '832': InsufficientFunds, // \"Not enougth X to create sell order.\" (selling with balance.base < order.amount)\n                    '833': OrderNotFound, // \"Order with id X was not found.\" (cancelling non-existent, closed and cancelled order)\n                },\n                'broad': {\n                    'Invalid pair name': ExchangeError, // {\"success\":0,\"error\":\"Invalid pair name: btc_eth\"}\n                    'invalid api key': AuthenticationError,\n                    'invalid sign': AuthenticationError,\n                    'api key dont have trade permission': AuthenticationError,\n                    'invalid parameter': InvalidOrder,\n                    'invalid order': InvalidOrder,\n                    'Requests too often': DDoSProtection,\n                    'not available': ExchangeNotAvailable,\n                    'data unavailable': ExchangeNotAvailable,\n                    'external service unavailable': ExchangeNotAvailable,\n                },\n            },\n            'options': {\n                'fetchTickersMaxLength': 2048,\n            },\n            'orders': {}, // orders cache / emulation\n        });\n    }\n\n    async fetchCurrencies (params = {}) {\n        const response = await this.webGetCurrency (params);\n        const result = {};\n        for (let i = 0; i < response.length; i++) {\n            const currency = response[i];\n            const id = this.safeString (currency, 'symbol');\n            const precision = currency['amountPoint'];\n            const code = this.safeCurrencyCode (id);\n            let active = currency['visible'] === true;\n            const canWithdraw = currency['withdrawEnable'] === true;\n            const canDeposit = currency['depositEnable'] === true;\n            if (!canWithdraw || !canDeposit) {\n                active = false;\n            }\n            const name = this.safeString (currency, 'name');\n            result[code] = {\n                'id': id,\n                'code': code,\n                'name': name,\n                'active': active,\n                'precision': precision,\n                'funding': {\n                    'withdraw': {\n                        'active': canWithdraw,\n                        'fee': currency['withdrawFee'],\n                    },\n                    'deposit': {\n                        'active': canDeposit,\n                        'fee': 0.0,\n                    },\n                },\n                'limits': {\n                    'amount': {\n                        'min': undefined,\n                        'max': Math.pow (10, precision),\n                    },\n                    'price': {\n                        'min': Math.pow (10, -precision),\n                        'max': Math.pow (10, precision),\n                    },\n                    'cost': {\n                        'min': undefined,\n                        'max': undefined,\n                    },\n                    'withdraw': {\n                        'min': this.safeFloat (currency, 'withdrawMinAmount'),\n                        'max': undefined,\n                    },\n                    'deposit': {\n                        'min': this.safeFloat (currency, 'depositMinAmount'),\n                        'max': undefined,\n                    },\n                },\n                'info': currency,\n            };\n        }\n        return result;\n    }\n\n    calculateFee (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {\n        const market = this.markets[symbol];\n        let key = 'quote';\n        const rate = market[takerOrMaker];\n        let cost = parseFloat (this.costToPrecision (symbol, amount * rate));\n        if (side === 'sell') {\n            cost *= price;\n        } else {\n            key = 'base';\n        }\n        return {\n            'type': takerOrMaker,\n            'currency': market[key],\n            'rate': rate,\n            'cost': cost,\n        };\n    }\n\n    async fetchMarkets (params = {}) {\n        const response = await this.publicGetInfo (params);\n        const markets = response['pairs'];\n        const keys = Object.keys (markets);\n        const result = [];\n        for (let i = 0; i < keys.length; i++) {\n            const id = keys[i];\n            const market = markets[id];\n            const [ baseId, quoteId ] = id.split ('_');\n            const base = this.safeCurrencyCode (baseId);\n            const quote = this.safeCurrencyCode (quoteId);\n            const symbol = base + '/' + quote;\n            const precision = {\n                'amount': this.safeInteger (market, 'decimal_places'),\n                'price': this.safeInteger (market, 'decimal_places'),\n            };\n            const limits = {\n                'amount': {\n                    'min': this.safeFloat (market, 'min_amount'),\n                    'max': this.safeFloat (market, 'max_amount'),\n                },\n                'price': {\n                    'min': this.safeFloat (market, 'min_price'),\n                    'max': this.safeFloat (market, 'max_price'),\n                },\n                'cost': {\n                    'min': this.safeFloat (market, 'min_total'),\n                },\n            };\n            const hidden = this.safeInteger (market, 'hidden');\n            const active = (hidden === 0);\n            result.push ({\n                'id': id,\n                'symbol': symbol,\n                'base': base,\n                'quote': quote,\n                'baseId': baseId,\n                'quoteId': quoteId,\n                'active': active,\n                'taker': market['fee'] / 100,\n                'precision': precision,\n                'limits': limits,\n                'info': market,\n            });\n        }\n        return result;\n    }\n\n    async fetchBalance (params = {}) {\n        await this.loadMarkets ();\n        const response = await this.privatePostGetInfoExt (params);\n        const balances = this.safeValue (response, 'return');\n        const result = { 'info': balances };\n        const funds = this.safeValue (balances, 'funds', {});\n        const currencyIds = Object.keys (funds);\n        for (let i = 0; i < currencyIds.length; i++) {\n            const currencyId = currencyIds[i];\n            const code = this.safeCurrencyCode (currencyId);\n            const balance = this.safeValue (funds, currencyId, {});\n            const account = this.account ();\n            account['free'] = this.safeFloat (balance, 'value');\n            account['used'] = this.safeFloat (balance, 'inOrders');\n            result[code] = account;\n        }\n        return this.parseBalance (result);\n    }\n\n    async fetchOrderBook (symbol, limit = undefined, params = {}) {\n        await this.loadMarkets ();\n        const market = this.market (symbol);\n        const request = {\n            'pair': market['id'],\n        };\n        if (limit !== undefined) {\n            request['limit'] = limit; // default = 150, max = 2000\n        }\n        const response = await this.publicGetDepthPair (this.extend (request, params));\n        const market_id_in_reponse = (market['id'] in response);\n        if (!market_id_in_reponse) {\n            throw new ExchangeError (this.id + ' ' + market['symbol'] + ' order book is empty or not available');\n        }\n        const orderbook = response[market['id']];\n        return this.parseOrderBook (orderbook);\n    }\n\n    async fetchOrderBooks (symbols = undefined, limit = undefined, params = {}) {\n        await this.loadMarkets ();\n        let ids = undefined;\n        if (symbols === undefined) {\n            ids = this.ids.join ('-');\n            // max URL length is 2083 symbols, including http schema, hostname, tld, etc...\n            if (ids.length > 2048) {\n                const numIds = this.ids.length;\n                throw new ExchangeError (this.id + ' has ' + numIds.toString () + ' symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks');\n            }\n        } else {\n            ids = this.marketIds (symbols);\n            ids = ids.join ('-');\n        }\n        const request = {\n            'pair': ids,\n        };\n        if (limit !== undefined) {\n            request['limit'] = limit; // default = 150, max = 2000\n        }\n        const response = await this.publicGetDepthPair (this.extend (request, params));\n        const result = {};\n        ids = Object.keys (response);\n        for (let i = 0; i < ids.length; i++) {\n            const id = ids[i];\n            const symbol = this.safeSymbol (id);\n            result[symbol] = this.parseOrderBook (response[id]);\n        }\n        return result;\n    }\n\n    parseTicker (ticker, market = undefined) {\n        //\n        //   {    high: 0.03497582,\n        //         low: 0.03248474,\n        //         avg: 0.03373028,\n        //         vol: 120.11485715062999,\n        //     vol_cur: 3572.24914074,\n        //        last: 0.0337611,\n        //         buy: 0.0337442,\n        //        sell: 0.03377798,\n        //     updated: 1537522009          }\n        //\n        let timestamp = this.safeTimestamp (ticker, 'updated');\n        let symbol = undefined;\n        if (market !== undefined) {\n            symbol = market['symbol'];\n            if (!market['active']) {\n                timestamp = undefined;\n            }\n        }\n        const last = this.safeFloat (ticker, 'last');\n        return {\n            'symbol': symbol,\n            'timestamp': timestamp,\n            'datetime': this.iso8601 (timestamp),\n            'high': this.safeFloat (ticker, 'high'),\n            'low': this.safeFloat (ticker, 'low'),\n            'bid': this.safeFloat (ticker, 'buy'),\n            'bidVolume': undefined,\n            'ask': this.safeFloat (ticker, 'sell'),\n            'askVolume': undefined,\n            'vwap': undefined,\n            'open': undefined,\n            'close': last,\n            'last': last,\n            'previousClose': undefined,\n            'change': undefined,\n            'percentage': undefined,\n            'average': this.safeFloat (ticker, 'avg'),\n            'baseVolume': this.safeFloat (ticker, 'vol_cur'),\n            'quoteVolume': this.safeFloat (ticker, 'vol'),\n            'info': ticker,\n        };\n    }\n\n    async fetchTickers (symbols = undefined, params = {}) {\n        await this.loadMarkets ();\n        let ids = this.ids;\n        if (symbols === undefined) {\n            const numIds = ids.length;\n            ids = ids.join ('-');\n            // max URL length is 2048 symbols, including http schema, hostname, tld, etc...\n            if (ids.length > this.options['fetchTickersMaxLength']) {\n                const maxLength = this.safeInteger (this.options, 'fetchTickersMaxLength', 2048);\n                throw new ArgumentsRequired (this.id + ' has ' + numIds.toString () + ' markets exceeding max URL length for this endpoint (' + maxLength.toString () + ' characters), please, specify a list of symbols of interest in the first argument to fetchTickers');\n            }\n        } else {\n            ids = this.marketIds (symbols);\n            ids = ids.join ('-');\n        }\n        const request = {\n            'pair': ids,\n        };\n        const response = await this.publicGetTickerPair (this.extend (request, params));\n        const result = {};\n        const keys = Object.keys (response);\n        for (let i = 0; i < keys.length; i++) {\n            const id = keys[i];\n            const market = this.safeMarket (id);\n            const symbol = market['symbol'];\n            result[symbol] = this.parseTicker (response[id], market);\n        }\n        return this.filterByArray (result, 'symbol', symbols);\n    }\n\n    async fetchTicker (symbol, params = {}) {\n        const tickers = await this.fetchTickers ([ symbol ], params);\n        return tickers[symbol];\n    }\n\n    parseTrade (trade, market = undefined) {\n        const timestamp = this.safeTimestamp (trade, 'timestamp');\n        let side = this.safeString (trade, 'type');\n        if (side === 'ask') {\n            side = 'sell';\n        } else if (side === 'bid') {\n            side = 'buy';\n        }\n        const price = this.safeFloat2 (trade, 'rate', 'price');\n        const id = this.safeString2 (trade, 'trade_id', 'tid');\n        const orderId = this.safeString (trade, 'order_id');\n        const marketId = this.safeString (trade, 'pair');\n        const symbol = this.safeSymbol (marketId, market);\n        const amount = this.safeFloat (trade, 'amount');\n        const type = 'limit'; // all trades are still limit trades\n        let takerOrMaker = undefined;\n        let fee = undefined;\n        const feeCost = this.safeFloat (trade, 'commission');\n        if (feeCost !== undefined) {\n            const feeCurrencyId = this.safeString (trade, 'commissionCurrency');\n            const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);\n            fee = {\n                'cost': feeCost,\n                'currency': feeCurrencyCode,\n            };\n        }\n        const isYourOrder = this.safeValue (trade, 'is_your_order');\n        if (isYourOrder !== undefined) {\n            takerOrMaker = 'taker';\n            if (isYourOrder) {\n                takerOrMaker = 'maker';\n            }\n            if (fee === undefined) {\n                fee = this.calculateFee (symbol, type, side, amount, price, takerOrMaker);\n            }\n        }\n        let cost = undefined;\n        if (amount !== undefined) {\n            if (price !== undefined) {\n                cost = amount * price;\n            }\n        }\n        return {\n            'id': id,\n            'order': orderId,\n            'timestamp': timestamp,\n            'datetime': this.iso8601 (timestamp),\n            'symbol': symbol,\n            'type': type,\n            'side': side,\n            'takerOrMaker': takerOrMaker,\n            'price': price,\n            'amount': amount,\n            'cost': cost,\n            'fee': fee,\n            'info': trade,\n        };\n    }\n\n    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {\n        await this.loadMarkets ();\n        const market = this.market (symbol);\n        const request = {\n            'pair': market['id'],\n        };\n        if (limit !== undefined) {\n            request['limit'] = limit;\n        }\n        const response = await this.publicGetTradesPair (this.extend (request, params));\n        if (Array.isArray (response)) {\n            const numElements = response.length;\n            if (numElements === 0) {\n                return [];\n            }\n        }\n        return this.parseTrades (response[market['id']], market, since, limit);\n    }\n\n    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {\n        if (type === 'market') {\n            throw new ExchangeError (this.id + ' allows limit orders only');\n        }\n        await this.loadMarkets ();\n        const market = this.market (symbol);\n        const request = {\n            'pair': market['id'],\n            'type': side,\n            'amount': this.amountToPrecision (symbol, amount),\n            'rate': this.priceToPrecision (symbol, price),\n        };\n        price = parseFloat (price);\n        amount = parseFloat (amount);\n        const response = await this.privatePostTrade (this.extend (request, params));\n        let id = undefined;\n        let status = 'open';\n        let filled = 0.0;\n        let remaining = amount;\n        if ('return' in response) {\n            id = this.safeString (response['return'], 'order_id');\n            if (id === '0') {\n                id = this.safeString (response['return'], 'init_order_id');\n                status = 'closed';\n            }\n            filled = this.safeFloat (response['return'], 'received', 0.0);\n            remaining = this.safeFloat (response['return'], 'remains', amount);\n        }\n        const timestamp = this.milliseconds ();\n        return {\n            'id': id,\n            'timestamp': timestamp,\n            'datetime': this.iso8601 (timestamp),\n            'lastTradeTimestamp': undefined,\n            'status': status,\n            'symbol': symbol,\n            'type': type,\n            'side': side,\n            'price': price,\n            'cost': price * filled,\n            'amount': amount,\n            'remaining': remaining,\n            'filled': filled,\n            'fee': undefined,\n            // 'trades': this.parseTrades (order['trades'], market),\n            'info': response,\n            'clientOrderId': undefined,\n            'average': undefined,\n            'trades': undefined,\n        };\n    }\n\n    async cancelOrder (id, symbol = undefined, params = {}) {\n        await this.loadMarkets ();\n        const request = {\n            'order_id': parseInt (id),\n        };\n        return await this.privatePostCancelOrder (this.extend (request, params));\n    }\n\n    parseOrderStatus (status) {\n        const statuses = {\n            '0': 'open',\n            '1': 'closed',\n            '2': 'canceled',\n            '3': 'canceled', // or partially-filled and still open? https://github.com/ccxt/ccxt/issues/1594\n        };\n        return this.safeString (statuses, status, status);\n    }\n\n    parseOrder (order, market = undefined) {\n        const id = this.safeString (order, 'id');\n        const status = this.parseOrderStatus (this.safeString (order, 'status'));\n        const timestamp = this.safeTimestamp (order, 'timestamp_created');\n        const marketId = this.safeString (order, 'pair');\n        const symbol = this.safeSymbol (marketId, market);\n        let remaining = undefined;\n        let amount = undefined;\n        const price = this.safeFloat (order, 'rate');\n        let filled = undefined;\n        let cost = undefined;\n        if ('start_amount' in order) {\n            amount = this.safeFloat (order, 'start_amount');\n            remaining = this.safeFloat (order, 'amount');\n        } else {\n            remaining = this.safeFloat (order, 'amount');\n        }\n        if (amount !== undefined) {\n            if (remaining !== undefined) {\n                filled = amount - remaining;\n                cost = price * filled;\n            }\n        }\n        const fee = undefined;\n        return {\n            'info': order,\n            'id': id,\n            'clientOrderId': undefined,\n            'symbol': symbol,\n            'timestamp': timestamp,\n            'datetime': this.iso8601 (timestamp),\n            'lastTradeTimestamp': undefined,\n            'type': 'limit',\n            'timeInForce': undefined,\n            'postOnly': undefined,\n            'side': this.safeString (order, 'type'),\n            'price': price,\n            'stopPrice': undefined,\n            'cost': cost,\n            'amount': amount,\n            'remaining': remaining,\n            'filled': filled,\n            'status': status,\n            'fee': fee,\n            'average': undefined,\n            'trades': undefined,\n        };\n    }\n\n    async fetchOrder (id, symbol = undefined, params = {}) {\n        await this.loadMarkets ();\n        const request = {\n            'order_id': parseInt (id),\n        };\n        const response = await this.privatePostOrderInfo (this.extend (request, params));\n        id = id.toString ();\n        const result = this.safeValue (response, 'return', {});\n        const order = this.safeValue (result, id);\n        return this.parseOrder (this.extend ({ 'id': id }, order));\n    }\n\n    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {\n        await this.loadMarkets ();\n        const request = {};\n        let market = undefined;\n        if (symbol !== undefined) {\n            market = this.market (symbol);\n            request['pair'] = market['id'];\n        }\n        const response = await this.privatePostActiveOrders (this.extend (request, params));\n        //\n        //     {\n        //         \"success\":1,\n        //         \"return\":{\n        //             \"1255468911\":{\n        //                 \"status\":0,\n        //                 \"pair\":\"spike_usdt\",\n        //                 \"type\":\"sell\",\n        //                 \"amount\":35028.44256388,\n        //                 \"rate\":0.00199989,\n        //                 \"timestamp_created\":1602684432\n        //             }\n        //         },\n        //         \"stat\":{\n        //             \"isSuccess\":true,\n        //             \"serverTime\":\"00:00:00.0000826\",\n        //             \"time\":\"00:00:00.0091423\",\n        //             \"errors\":null\n        //         }\n        //     }\n        //\n        // it can only return 'open' orders (i.e. no way to fetch 'closed' orders)\n        const orders = this.safeValue (response, 'return', []);\n        return this.parseOrders (orders, market, since, limit);\n    }\n\n    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {\n        await this.loadMarkets ();\n        let market = undefined;\n        // some derived classes use camelcase notation for request fields\n        const request = {\n            // 'from': 123456789, // trade ID, from which the display starts numerical 0 (test result: liqui ignores this field)\n            // 'count': 1000, // the number of trades for display numerical, default = 1000\n            // 'from_id': trade ID, from which the display starts numerical 0\n            // 'end_id': trade ID on which the display ends numerical ∞\n            // 'order': 'ASC', // sorting, default = DESC (test result: liqui ignores this field, most recent trade always goes last)\n            // 'since': 1234567890, // UTC start time, default = 0 (test result: liqui ignores this field)\n            // 'end': 1234567890, // UTC end time, default = ∞ (test result: liqui ignores this field)\n            // 'pair': 'eth_btc', // default = all markets\n        };\n        if (symbol !== undefined) {\n            market = this.market (symbol);\n            request['pair'] = market['id'];\n        }\n        if (limit !== undefined) {\n            request['count'] = parseInt (limit);\n        }\n        if (since !== undefined) {\n            request['since'] = parseInt (since / 1000);\n        }\n        const response = await this.privatePostTradeHistory (this.extend (request, params));\n        const trades = this.safeValue (response, 'return', []);\n        return this.parseTrades (trades, market, since, limit);\n    }\n\n    async withdraw (code, amount, address, tag = undefined, params = {}) {\n        this.checkAddress (address);\n        await this.loadMarkets ();\n        const currency = this.currency (code);\n        const request = {\n            'coinName': currency['id'],\n            'amount': parseFloat (amount),\n            'address': address,\n        };\n        // no docs on the tag, yet...\n        if (tag !== undefined) {\n            throw new ExchangeError (this.id + ' withdraw() does not support the tag argument yet due to a lack of docs on withdrawing with tag/memo on behalf of the exchange.');\n        }\n        const response = await this.privatePostWithdrawCoin (this.extend (request, params));\n        return {\n            'info': response,\n            'id': response['return']['tId'],\n        };\n    }\n\n    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {\n        let url = this.urls['api'][api];\n        const query = this.omit (params, this.extractParams (path));\n        if (api === 'private') {\n            this.checkRequiredCredentials ();\n            const nonce = this.nonce ();\n            body = this.urlencode (this.extend ({\n                'nonce': nonce,\n                'method': path,\n            }, query));\n            const signature = this.hmac (this.encode (body), this.encode (this.secret), 'sha512');\n            headers = {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'Key': this.apiKey,\n                'Sign': signature,\n            };\n        } else if (api === 'public') {\n            url += '/' + this.implodeParams (path, params);\n            if (Object.keys (query).length) {\n                url += '?' + this.urlencode (query);\n            }\n        } else {\n            url += '/' + this.implodeParams (path, params);\n            if (method === 'GET') {\n                if (Object.keys (query).length) {\n                    url += '?' + this.urlencode (query);\n                }\n            } else {\n                if (Object.keys (query).length) {\n                    body = this.json (query);\n                    headers = {\n                        'Content-Type': 'application/json',\n                    };\n                }\n            }\n        }\n        return { 'url': url, 'method': method, 'body': body, 'headers': headers };\n    }\n\n    handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {\n        if (response === undefined) {\n            return; // fallback to default error handler\n        }\n        if ('success' in response) {\n            //\n            // 1 - The exchange only returns the integer 'success' key from their private API\n            //\n            //     { \"success\": 1, ... } httpCode === 200\n            //     { \"success\": 0, ... } httpCode === 200\n            //\n            // 2 - However, derived exchanges can return non-integers\n            //\n            //     It can be a numeric string\n            //     { \"sucesss\": \"1\", ... }\n            //     { \"sucesss\": \"0\", ... }, httpCode >= 200 (can be 403, 502, etc)\n            //\n            //     Or just a string\n            //     { \"success\": \"true\", ... }\n            //     { \"success\": \"false\", ... }, httpCode >= 200\n            //\n            //     Or a boolean\n            //     { \"success\": true, ... }\n            //     { \"success\": false, ... }, httpCode >= 200\n            //\n            // 3 - Oversimplified, Python PEP8 forbids comparison operator (===) of different types\n            //\n            // 4 - We do not want to copy-paste and duplicate the code of this handler to other exchanges derived from Liqui\n            //\n            // To cover points 1, 2, 3 and 4 combined this handler should work like this:\n            //\n            let success = this.safeValue (response, 'success', false);\n            if (typeof success === 'string') {\n                if ((success === 'true') || (success === '1')) {\n                    success = true;\n                } else {\n                    success = false;\n                }\n            }\n            if (!success) {\n                const code = this.safeString (response, 'code');\n                const message = this.safeString (response, 'error');\n                const feedback = this.id + ' ' + body;\n                this.throwExactlyMatchedException (this.exceptions['exact'], code, feedback);\n                this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);\n                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);\n                throw new ExchangeError (feedback); // unknown message\n            }\n        }\n    }\n};\n"]},"metadata":{},"sourceType":"script"}