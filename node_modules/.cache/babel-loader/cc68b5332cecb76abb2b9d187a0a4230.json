{"ast":null,"code":"/**\n * PKCS1 padding and signature scheme\n */\nvar BigInteger = require('../libs/jsbn');\n\nvar CryptoJS = require('../../crypto-js/crypto-js');\n\nvar constants = {\n  RSA_NO_PADDING: 3\n};\n\nrequire('constants');\n\nvar SIGN_INFO_HEAD = {\n  md2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),\n  md5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),\n  sha1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),\n  sha224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),\n  sha256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),\n  sha384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),\n  sha512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),\n  ripemd160: Buffer.from('3021300906052b2403020105000414', 'hex'),\n  rmd160: Buffer.from('3021300906052b2403020105000414', 'hex')\n};\nvar SIGN_ALG_TO_HASH_ALIASES = {\n  'ripemd160': 'rmd160'\n};\nvar DEFAULT_HASH_FUNCTION = 'sha256';\nmodule.exports = {\n  isEncryption: true,\n  isSignature: true\n};\n\nmodule.exports.makeScheme = function (key, options) {\n  function Scheme(key, options) {\n    this.key = key;\n    this.options = options;\n  }\n\n  Scheme.prototype.maxMessageLength = function () {\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      return this.key.encryptedDataLength;\n    }\n\n    return this.key.encryptedDataLength - 11;\n  };\n  /**\n   * Unpad input Buffer and, if valid, return the Buffer object\n   * alg: PKCS#1 (type 2, random)\n   * @param buffer\n   * @returns {Buffer}\n   */\n\n\n  Scheme.prototype.encUnPad = function (buffer, options) {\n    options = options || {};\n    var i = 0;\n\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING treated like JAVA left pad with zero character\n      var unPad;\n\n      if (typeof buffer.lastIndexOf == \"function\") {\n        //patch for old node version\n        unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n      } else {\n        unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n      }\n\n      return unPad;\n    }\n\n    if (buffer.length < 4) {\n      return null;\n    }\n    /* Type 1: zeros padding for private key decrypt */\n\n\n    if (options.type === 1) {\n      if (buffer[0] !== 0 && buffer[1] !== 1) {\n        return null;\n      }\n\n      i = 3;\n\n      while (buffer[i] !== 0) {\n        if (buffer[i] != 0xFF || ++i >= buffer.length) {\n          return null;\n        }\n      }\n    } else {\n      /* random padding for public key decrypt */\n      if (buffer[0] !== 0 && buffer[1] !== 2) {\n        return null;\n      }\n\n      i = 3;\n\n      while (buffer[i] !== 0) {\n        if (++i >= buffer.length) {\n          return null;\n        }\n      }\n    }\n\n    return buffer.slice(i + 1, buffer.length);\n  };\n\n  Scheme.prototype.sign = function (buffer) {\n    var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n\n    if (this.options.environment === 'browser') {\n      hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n      var hasher = CryptoJS[hashAlgorithm.toUpperCase()](buffer.toString());\n      var asBuffer = wordArrayToBuffer(hasher);\n      var paddedHash = this.pkcs1pad(asBuffer, hashAlgorithm);\n      var res = this.key.$doPrivate(new BigInteger(paddedHash)).toBuffer(this.key.encryptedDataLength);\n      return res;\n    } else {\n      throw new Error('CCXT only supports browser mode :P');\n    }\n  };\n  /**\n   * PKCS#1 pad input buffer to max data length\n   * @param hashBuf\n   * @param hashAlgorithm\n   * @returns {*}\n   */\n\n\n  Scheme.prototype.pkcs1pad = function (hashBuf, hashAlgorithm) {\n    var digest = SIGN_INFO_HEAD[hashAlgorithm];\n\n    if (!digest) {\n      throw Error('Unsupported hash algorithm');\n    }\n\n    var data = Buffer.concat([digest, hashBuf]);\n\n    if (data.length + 10 > this.key.encryptedDataLength) {\n      throw Error('Key is too short for signing algorithm (' + hashAlgorithm + ')');\n    }\n\n    var filled = Buffer.alloc(this.key.encryptedDataLength - data.length - 1);\n    filled.fill(0xff, 0, filled.length - 1);\n    filled[0] = 1;\n    filled[filled.length - 1] = 0;\n    var res = Buffer.concat([filled, data]);\n    return res;\n  };\n\n  return new Scheme(key, options);\n}; // used to convert `CryptoJS` wordArrays into `crypto` hex buffers\n\n\nfunction wordToByteArray(word, length) {\n  var ba = [],\n      xFF = 0xFF;\n  if (length > 0) ba.push(word >>> 24);\n  if (length > 1) ba.push(word >>> 16 & xFF);\n  if (length > 2) ba.push(word >>> 8 & xFF);\n  if (length > 3) ba.push(word & xFF);\n  return ba;\n}\n\nfunction wordArrayToBuffer(wordArray) {\n  let length = undefined;\n\n  if (wordArray.hasOwnProperty(\"sigBytes\") && wordArray.hasOwnProperty(\"words\")) {\n    length = wordArray.sigBytes;\n    wordArray = wordArray.words;\n  } else {\n    throw Error('Argument not a wordArray');\n  }\n\n  const result = [];\n  let bytes = [];\n  let i = 0;\n\n  while (length > 0) {\n    bytes = wordToByteArray(wordArray[i], Math.min(4, length));\n    length -= bytes.length;\n    result.push(bytes);\n    i++;\n  }\n\n  return new Buffer.from([].concat.apply([], result), 'hex');\n}","map":{"version":3,"sources":["C:/Users/senya/Documents/Coding/React Projects/react-stock-ticker/node_modules/ccxt/js/static_dependencies/node-rsa/schemes/pkcs1.js"],"names":["BigInteger","require","CryptoJS","constants","RSA_NO_PADDING","SIGN_INFO_HEAD","md2","Buffer","from","md5","sha1","sha224","sha256","sha384","sha512","ripemd160","rmd160","SIGN_ALG_TO_HASH_ALIASES","DEFAULT_HASH_FUNCTION","module","exports","isEncryption","isSignature","makeScheme","key","options","Scheme","prototype","maxMessageLength","encryptionSchemeOptions","padding","encryptedDataLength","encUnPad","buffer","i","unPad","lastIndexOf","slice","length","String","call","type","sign","hashAlgorithm","signingSchemeOptions","hash","environment","hasher","toUpperCase","toString","asBuffer","wordArrayToBuffer","paddedHash","pkcs1pad","res","$doPrivate","toBuffer","Error","hashBuf","digest","data","concat","filled","alloc","fill","wordToByteArray","word","ba","xFF","push","wordArray","undefined","hasOwnProperty","sigBytes","words","result","bytes","Math","min","apply"],"mappings":"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","sourcesContent":["/**\n * PKCS1 padding and signature scheme\n */\n\nvar BigInteger = require('../libs/jsbn');\nvar CryptoJS = require('../../crypto-js/crypto-js');\nvar constants = { RSA_NO_PADDING: 3 }\nrequire('constants');\nvar SIGN_INFO_HEAD = {\n    md2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),\n    md5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),\n    sha1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),\n    sha224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),\n    sha256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),\n    sha384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),\n    sha512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),\n    ripemd160: Buffer.from('3021300906052b2403020105000414', 'hex'),\n    rmd160: Buffer.from('3021300906052b2403020105000414', 'hex')\n};\n\nvar SIGN_ALG_TO_HASH_ALIASES = {\n    'ripemd160': 'rmd160'\n};\n\nvar DEFAULT_HASH_FUNCTION = 'sha256';\n\nmodule.exports = {\n    isEncryption: true,\n    isSignature: true\n};\n\nmodule.exports.makeScheme = function (key, options) {\n    function Scheme(key, options) {\n        this.key = key;\n        this.options = options;\n    }\n\n    Scheme.prototype.maxMessageLength = function () {\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            return this.key.encryptedDataLength;\n        }\n        return this.key.encryptedDataLength - 11;\n    };\n\n    /**\n     * Unpad input Buffer and, if valid, return the Buffer object\n     * alg: PKCS#1 (type 2, random)\n     * @param buffer\n     * @returns {Buffer}\n     */\n    Scheme.prototype.encUnPad = function (buffer, options) {\n        options = options || {};\n        var i = 0;\n\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING treated like JAVA left pad with zero character\n            var unPad;\n            if (typeof buffer.lastIndexOf == \"function\") { //patch for old node version\n                unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n            } else {\n                unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n            }\n            return unPad;\n        }\n\n        if (buffer.length < 4) {\n            return null;\n        }\n\n        /* Type 1: zeros padding for private key decrypt */\n        if (options.type === 1) {\n            if (buffer[0] !== 0 && buffer[1] !== 1) {\n                return null;\n            }\n            i = 3;\n            while (buffer[i] !== 0) {\n                if (buffer[i] != 0xFF || ++i >= buffer.length) {\n                    return null;\n                }\n            }\n        } else {\n            /* random padding for public key decrypt */\n            if (buffer[0] !== 0 && buffer[1] !== 2) {\n                return null;\n            }\n            i = 3;\n            while (buffer[i] !== 0) {\n                if (++i >= buffer.length) {\n                    return null;\n                }\n            }\n        }\n        return buffer.slice(i + 1, buffer.length);\n    };\n\n    Scheme.prototype.sign = function (buffer) {\n        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        if (this.options.environment === 'browser') {\n            hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n            var hasher = CryptoJS[hashAlgorithm.toUpperCase()] (buffer.toString());\n            var asBuffer = wordArrayToBuffer(hasher)\n            var paddedHash = this.pkcs1pad(asBuffer, hashAlgorithm);\n            var res = this.key.$doPrivate(new BigInteger(paddedHash)).toBuffer(this.key.encryptedDataLength);\n            return res;\n        } else {\n            throw new Error ('CCXT only supports browser mode :P');\n        }\n    };\n\n    /**\n     * PKCS#1 pad input buffer to max data length\n     * @param hashBuf\n     * @param hashAlgorithm\n     * @returns {*}\n     */\n    Scheme.prototype.pkcs1pad = function (hashBuf, hashAlgorithm) {\n        var digest = SIGN_INFO_HEAD[hashAlgorithm];\n        if (!digest) {\n            throw Error('Unsupported hash algorithm');\n        }\n\n        var data = Buffer.concat([digest, hashBuf]);\n\n        if (data.length + 10 > this.key.encryptedDataLength) {\n            throw Error('Key is too short for signing algorithm (' + hashAlgorithm + ')');\n        }\n\n        var filled = Buffer.alloc(this.key.encryptedDataLength - data.length - 1);\n        filled.fill(0xff, 0, filled.length - 1);\n        filled[0] = 1;\n        filled[filled.length - 1] = 0;\n\n        var res = Buffer.concat([filled, data]);\n\n        return res;\n    };\n\n    return new Scheme(key, options);\n};\n\n// used to convert `CryptoJS` wordArrays into `crypto` hex buffers\nfunction wordToByteArray(word, length) {\n    var ba = [],\n        xFF = 0xFF;\n    if (length > 0)\n        ba.push(word >>> 24);\n    if (length > 1)\n        ba.push((word >>> 16) & xFF);\n    if (length > 2)\n        ba.push((word >>> 8) & xFF);\n    if (length > 3)\n        ba.push(word & xFF);\n\n    return ba;\n}\n\nfunction wordArrayToBuffer(wordArray) {\n    let length = undefined;\n    if (wordArray.hasOwnProperty(\"sigBytes\") && wordArray.hasOwnProperty(\"words\")) {\n        length = wordArray.sigBytes;\n        wordArray = wordArray.words;\n    } else {\n        throw Error('Argument not a wordArray')\n    }\n\n    const result = []\n    let bytes = []\n    let i = 0;\n    while (length > 0) {\n        bytes = wordToByteArray(wordArray[i], Math.min(4, length));\n        length -= bytes.length;\n        result.push(bytes);\n        i++;\n    }\n    return new Buffer.from([].concat.apply([], result), 'hex');\n}\n"]},"metadata":{},"sourceType":"script"}