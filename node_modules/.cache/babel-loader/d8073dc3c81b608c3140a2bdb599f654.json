{"ast":null,"code":"\"use strict\";\n/*  ------------------------------------------------------------------------ */\n\nconst {\n  sleep,\n  now\n} = require('./time');\n/*  ------------------------------------------------------------------------ */\n\n\nmodule.exports = {\n  throttle: function throttle(cfg) {\n    let lastTimestamp = now(),\n        numTokens = cfg.numTokens !== undefined ? cfg.numTokens : cfg.capacity,\n        running = false,\n        counter = 0;\n    const queue = [];\n    return Object.assign((rateLimit, cost) => {\n      if (queue.length > cfg.maxCapacity) throw new Error('Backlog is over max capacity of ' + cfg.maxCapacity);\n      return new Promise(async (resolve, reject) => {\n        try {\n          queue.push({\n            cost,\n            resolve,\n            reject\n          });\n\n          if (!running) {\n            running = true;\n\n            while (queue.length > 0) {\n              const hasEnoughTokens = cfg.capacity ? numTokens > 0 : numTokens >= 0;\n\n              if (hasEnoughTokens) {\n                if (queue.length > 0) {\n                  let {\n                    cost,\n                    resolve,\n                    reject\n                  } = queue[0];\n                  cost = cost || cfg.defaultCost;\n\n                  if (numTokens >= Math.min(cost, cfg.capacity)) {\n                    numTokens -= cost;\n                    queue.shift();\n                    resolve();\n                  }\n                }\n              }\n\n              const t = now(),\n                    elapsed = t - lastTimestamp;\n              lastTimestamp = t;\n              numTokens = Math.min(cfg.capacity, numTokens + elapsed * (1 / rateLimit));\n              await sleep(cfg.delay);\n            }\n\n            running = false;\n          }\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }, cfg, {\n      configure: newCfg => throttle(Object.assign({}, cfg, newCfg))\n    });\n  }\n};\n/*  ------------------------------------------------------------------------ */","map":{"version":3,"sources":["C:/Users/senya/Documents/Coding/React Projects/react-stock-ticker/node_modules/ccxt/js/base/functions/throttle.js"],"names":["sleep","now","require","module","exports","throttle","cfg","lastTimestamp","numTokens","undefined","capacity","running","counter","queue","Object","assign","rateLimit","cost","length","maxCapacity","Error","Promise","resolve","reject","push","hasEnoughTokens","defaultCost","Math","min","shift","t","elapsed","delay","e","configure","newCfg"],"mappings":"AAAA;AAEA;;AAEA,MAAM;AAAEA,EAAAA,KAAF;AACEC,EAAAA;AADF,IACUC,OAAO,CAAE,QAAF,CADvB;AAGA;;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AAEbC,EAAAA,QAAQ,EAAE,SAASA,QAAT,CAAmBC,GAAnB,EAAwB;AAE9B,QAAMC,aAAa,GAAGN,GAAG,EAAzB;AAAA,QACMO,SAAS,GAAQF,GAAG,CAACE,SAAJ,KAAkBC,SAAnB,GAAgCH,GAAG,CAACE,SAApC,GAAgDF,GAAG,CAACI,QAD1E;AAAA,QAEMC,OAAO,GAAS,KAFtB;AAAA,QAGMC,OAAO,GAAS,CAHtB;AAKA,UAAMC,KAAK,GAAG,EAAd;AAEA,WAAOC,MAAM,CAACC,MAAP,CAAe,CAACC,SAAD,EAAYC,IAAZ,KAAqB;AAEvC,UAAIJ,KAAK,CAACK,MAAN,GAAeZ,GAAG,CAACa,WAAvB,EACI,MAAM,IAAIC,KAAJ,CAAW,qCAAqCd,GAAG,CAACa,WAApD,CAAN;AAEJ,aAAO,IAAIE,OAAJ,CAAa,OAAOC,OAAP,EAAgBC,MAAhB,KAA2B;AAE3C,YAAI;AACAV,UAAAA,KAAK,CAACW,IAAN,CAAY;AAAEP,YAAAA,IAAF;AAAQK,YAAAA,OAAR;AAAiBC,YAAAA;AAAjB,WAAZ;;AAEA,cAAI,CAACZ,OAAL,EAAc;AACVA,YAAAA,OAAO,GAAG,IAAV;;AACA,mBAAOE,KAAK,CAACK,MAAN,GAAe,CAAtB,EAAyB;AACrB,oBAAMO,eAAe,GAAGnB,GAAG,CAACI,QAAJ,GAAgBF,SAAS,GAAG,CAA5B,GAAkCA,SAAS,IAAI,CAAvE;;AACA,kBAAIiB,eAAJ,EAAqB;AACjB,oBAAIZ,KAAK,CAACK,MAAN,GAAe,CAAnB,EAAsB;AAClB,sBAAI;AAAED,oBAAAA,IAAF;AAAQK,oBAAAA,OAAR;AAAiBC,oBAAAA;AAAjB,sBAA4BV,KAAK,CAAC,CAAD,CAArC;AACAI,kBAAAA,IAAI,GAAIA,IAAI,IAAIX,GAAG,CAACoB,WAApB;;AACA,sBAAIlB,SAAS,IAAImB,IAAI,CAACC,GAAL,CAAUX,IAAV,EAAgBX,GAAG,CAACI,QAApB,CAAjB,EAAgD;AAC5CF,oBAAAA,SAAS,IAAIS,IAAb;AACAJ,oBAAAA,KAAK,CAACgB,KAAN;AACAP,oBAAAA,OAAO;AACV;AACJ;AACJ;;AACD,oBAAMQ,CAAC,GAAG7B,GAAG,EAAb;AAAA,oBACM8B,OAAO,GAAGD,CAAC,GAAGvB,aADpB;AAEAA,cAAAA,aAAa,GAAGuB,CAAhB;AACAtB,cAAAA,SAAS,GAAGmB,IAAI,CAACC,GAAL,CAAUtB,GAAG,CAACI,QAAd,EAAwBF,SAAS,GAAGuB,OAAO,IAAI,IAAIf,SAAR,CAA3C,CAAZ;AACA,oBAAMhB,KAAK,CAAEM,GAAG,CAAC0B,KAAN,CAAX;AACH;;AACDrB,YAAAA,OAAO,GAAG,KAAV;AACH;AAEJ,SA3BD,CA2BE,OAAOsB,CAAP,EAAU;AACRV,UAAAA,MAAM,CAAEU,CAAF,CAAN;AACH;AACJ,OAhCM,CAAP;AAkCH,KAvCM,EAuCJ3B,GAvCI,EAuCC;AAAE4B,MAAAA,SAAS,EAAEC,MAAM,IAAI9B,QAAQ,CAAES,MAAM,CAACC,MAAP,CAAe,EAAf,EAAmBT,GAAnB,EAAwB6B,MAAxB,CAAF;AAA/B,KAvCD,CAAP;AAwCH;AAnDY,CAAjB;AAsDA","sourcesContent":["\"use strict\";\n\n/*  ------------------------------------------------------------------------ */\n\nconst { sleep\n      , now } = require ('./time')\n\n/*  ------------------------------------------------------------------------ */\n\nmodule.exports = {\n\n    throttle: function throttle (cfg) {\n\n        let   lastTimestamp = now ()\n            , numTokens     = (cfg.numTokens !== undefined) ? cfg.numTokens : cfg.capacity\n            , running       = false\n            , counter       = 0\n\n        const queue = []\n\n        return Object.assign ((rateLimit, cost) => {\n\n            if (queue.length > cfg.maxCapacity)\n                throw new Error ('Backlog is over max capacity of ' + cfg.maxCapacity)\n\n            return new Promise (async (resolve, reject) => {\n\n                try {\n                    queue.push ({ cost, resolve, reject })\n\n                    if (!running) {\n                        running = true\n                        while (queue.length > 0) {\n                            const hasEnoughTokens = cfg.capacity ? (numTokens > 0) : (numTokens >= 0)\n                            if (hasEnoughTokens) {\n                                if (queue.length > 0) {\n                                    let { cost, resolve, reject } = queue[0]\n                                    cost = (cost || cfg.defaultCost)\n                                    if (numTokens >= Math.min (cost, cfg.capacity)) {\n                                        numTokens -= cost\n                                        queue.shift ()\n                                        resolve ()\n                                    }\n                                }\n                            }\n                            const t = now ()\n                                , elapsed = t - lastTimestamp\n                            lastTimestamp = t\n                            numTokens = Math.min (cfg.capacity, numTokens + elapsed * (1 / rateLimit))\n                            await sleep (cfg.delay)\n                        }\n                        running = false\n                    }\n\n                } catch (e) {\n                    reject (e)\n                }\n            })\n\n        }, cfg, { configure: newCfg => throttle (Object.assign ({}, cfg, newCfg)) })\n    }\n}\n\n/*  ------------------------------------------------------------------------ */\n"]},"metadata":{},"sourceType":"script"}