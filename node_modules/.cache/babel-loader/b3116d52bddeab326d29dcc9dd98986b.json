{"ast":null,"code":"'use strict';\n/*  ------------------------------------------------------------------------ */\n\nconst CryptoJS = require('../../static_dependencies/crypto-js/crypto-js');\n\nconst {\n  capitalize\n} = require('./string');\n\nconst {\n  stringToBase64,\n  urlencodeBase64\n} = require('./encode');\n\nconst NodeRSA = require('./../../static_dependencies/node-rsa/NodeRSA');\n\nconst {\n  binaryToBase58,\n  byteArrayToWordArray\n} = require('./encode');\n\nconst elliptic = require('./../../static_dependencies/elliptic/lib/elliptic');\n\nconst EC = elliptic.ec;\nconst EDDSA = elliptic.eddsa;\n\nconst {\n  ArgumentsRequired\n} = require('./../errors');\n\nconst BN = require('../../static_dependencies/BN/bn.js');\n/*  ------------------------------------------------------------------------ */\n\n\nconst hash = (request, hash = 'md5', digest = 'hex') => {\n  const options = {};\n\n  if (hash === 'keccak') {\n    hash = 'SHA3';\n    options['outputLength'] = 256;\n  }\n\n  const result = CryptoJS[hash.toUpperCase()](request, options);\n  return digest === 'binary' ? result : result.toString(CryptoJS.enc[capitalize(digest)]);\n};\n/*  .............................................   */\n\n\nconst hmac = (request, secret, hash = 'sha256', digest = 'hex') => {\n  const result = CryptoJS['Hmac' + hash.toUpperCase()](request, secret);\n\n  if (digest) {\n    const encoding = digest === 'binary' ? 'Latin1' : capitalize(digest);\n    return result.toString(CryptoJS.enc[capitalize(encoding)]);\n  }\n\n  return result;\n};\n/*  .............................................   */\n\n\nfunction rsa(request, secret, alg = 'RS256') {\n  const algos = {\n    'RS256': 'pkcs1-sha256',\n    'RS512': 'pkcs1-sha512'\n  };\n\n  if (!(alg in algos)) {\n    throw new ExchangeError(alg + ' is not a supported rsa signing algorithm.');\n  }\n\n  const algorithm = algos[alg];\n  let key = new NodeRSA(secret, {\n    'environment': 'browser',\n    'signingScheme': algorithm\n  });\n  return key.sign(request, 'base64', 'binary');\n}\n/**\n * @return {string}\n */\n\n\nfunction jwt(request, secret, alg = 'HS256') {\n  const algos = {\n    'HS256': 'sha256',\n    'HS384': 'sha384',\n    'HS512': 'sha512'\n  };\n  const encodedHeader = urlencodeBase64(stringToBase64(JSON.stringify({\n    'alg': alg,\n    'typ': 'JWT'\n  })));\n  const encodedData = urlencodeBase64(stringToBase64(JSON.stringify(request)));\n  const token = [encodedHeader, encodedData].join('.');\n  const algoType = alg.slice(0, 2);\n  const algorithm = algos[alg];\n  let signature = undefined;\n\n  if (algoType === 'HS') {\n    signature = urlencodeBase64(hmac(token, secret, algorithm, 'base64'));\n  } else if (algoType === 'RS') {\n    signature = urlencodeBase64(rsa(token, secret, alg));\n  }\n\n  return [token, signature].join('.');\n}\n\nfunction ecdsa(request, secret, algorithm = 'p256', hashFunction = undefined, fixedLength = false) {\n  let digest = request;\n\n  if (hashFunction !== undefined) {\n    digest = hash(request, hashFunction, 'hex');\n  }\n\n  const curve = new EC(algorithm);\n  let signature = curve.sign(digest, secret, 'hex', {\n    'canonical': true\n  });\n  let counter = new BN('0');\n  const minimum_size = new BN('1').shln(8 * 31).sub(new BN('1'));\n\n  while (fixedLength && (signature.r.gt(curve.nh) || signature.r.lte(minimum_size) || signature.s.lte(minimum_size))) {\n    signature = curve.sign(digest, secret, 'hex', {\n      'canonical': true,\n      'extraEntropy': counter.toArray('le', 32)\n    });\n    counter = counter.add(new BN('1'));\n  }\n\n  return {\n    'r': signature.r.toString(16).padStart(64, '0'),\n    's': signature.s.toString(16).padStart(64, '0'),\n    'v': signature.recoveryParam\n  };\n}\n\nfunction eddsa(request, secret, algorithm = 'ed25519') {\n  // used for waves.exchange (that's why the output is base58)\n  const curve = new EDDSA(algorithm);\n  const signature = curve.signModified(request, secret);\n  return binaryToBase58(byteArrayToWordArray(signature.toBytes()));\n}\n/*  ------------------------------------------------------------------------ */\n\n\nconst totp = secret => {\n  const dec2hex = s => (s < 15.5 ? '0' : '') + Math.round(s).toString(16),\n        hex2dec = s => parseInt(s, 16),\n        leftpad = (s, p) => (p + s).slice(-p.length); // both s and p are short strings\n\n\n  const base32tohex = base32 => {\n    let base32chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n    let bits = '';\n    let hex = '';\n\n    for (let i = 0; i < base32.length; i++) {\n      let val = base32chars.indexOf(base32.charAt(i).toUpperCase());\n      bits += leftpad(val.toString(2), '00000');\n    }\n\n    for (let i = 0; i + 4 <= bits.length; i += 4) {\n      let chunk = bits.substr(i, 4);\n      hex = hex + parseInt(chunk, 2).toString(16);\n    }\n\n    return hex;\n  };\n\n  const getOTP = secret => {\n    secret = secret.replace(' ', ''); // support 2fa-secrets with spaces like \"4TDV WOGO\" → \"4TDVWOGO\"\n\n    let epoch = Math.round(new Date().getTime() / 1000.0);\n    let time = leftpad(dec2hex(Math.floor(epoch / 30)), '0000000000000000');\n    let hmacRes = hmac(CryptoJS.enc.Hex.parse(time), CryptoJS.enc.Hex.parse(base32tohex(secret)), 'sha1', 'hex');\n    let offset = hex2dec(hmacRes.substring(hmacRes.length - 1));\n    let otp = (hex2dec(hmacRes.substr(offset * 2, 8)) & hex2dec('7fffffff')) + '';\n    otp = otp.substr(otp.length - 6, 6);\n    return otp;\n  };\n\n  return getOTP(secret);\n};\n/*  ------------------------------------------------------------------------ */\n\n\nmodule.exports = {\n  hash,\n  hmac,\n  jwt,\n  totp,\n  rsa,\n  ecdsa,\n  eddsa\n};\n/*  ------------------------------------------------------------------------ */","map":{"version":3,"sources":["C:/Users/senya/Documents/Coding/React Projects/react-stock-ticker/node_modules/ccxt/js/base/functions/crypto.js"],"names":["CryptoJS","require","capitalize","stringToBase64","urlencodeBase64","NodeRSA","binaryToBase58","byteArrayToWordArray","elliptic","EC","ec","EDDSA","eddsa","ArgumentsRequired","BN","hash","request","digest","options","result","toUpperCase","toString","enc","hmac","secret","encoding","rsa","alg","algos","ExchangeError","algorithm","key","sign","jwt","encodedHeader","JSON","stringify","encodedData","token","join","algoType","slice","signature","undefined","ecdsa","hashFunction","fixedLength","curve","counter","minimum_size","shln","sub","r","gt","nh","lte","s","toArray","add","padStart","recoveryParam","signModified","toBytes","totp","dec2hex","Math","round","hex2dec","parseInt","leftpad","p","length","base32tohex","base32","base32chars","bits","hex","i","val","indexOf","charAt","chunk","substr","getOTP","replace","epoch","Date","getTime","time","floor","hmacRes","Hex","parse","offset","substring","otp","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/*  ------------------------------------------------------------------------ */\n\nconst CryptoJS = require ('../../static_dependencies/crypto-js/crypto-js')\nconst { capitalize } = require ('./string')\nconst { stringToBase64, urlencodeBase64 } = require ('./encode')\nconst NodeRSA = require ('./../../static_dependencies/node-rsa/NodeRSA')\nconst { binaryToBase58, byteArrayToWordArray } = require ('./encode')\nconst elliptic = require ('./../../static_dependencies/elliptic/lib/elliptic')\nconst EC = elliptic.ec\nconst EDDSA = elliptic.eddsa\nconst { ArgumentsRequired } = require ('./../errors')\nconst BN = require ('../../static_dependencies/BN/bn.js')\n\n/*  ------------------------------------------------------------------------ */\n\nconst hash = (request, hash = 'md5', digest = 'hex') => {\n    const options = {}\n    if (hash === 'keccak') {\n        hash = 'SHA3'\n        options['outputLength'] = 256\n    }\n    const result = CryptoJS[hash.toUpperCase ()] (request, options)\n    return (digest === 'binary') ? result : result.toString (CryptoJS.enc[capitalize (digest)])\n}\n\n/*  .............................................   */\n\nconst hmac = (request, secret, hash = 'sha256', digest = 'hex') => {\n    const result = CryptoJS['Hmac' + hash.toUpperCase ()] (request, secret)\n    if (digest) {\n        const encoding = (digest === 'binary') ? 'Latin1' : capitalize (digest)\n        return result.toString (CryptoJS.enc[capitalize (encoding)])\n    }\n    return result\n}\n\n/*  .............................................   */\n\nfunction rsa (request, secret, alg = 'RS256') {\n    const algos = {\n        'RS256': 'pkcs1-sha256',\n        'RS512': 'pkcs1-sha512',\n    }\n    if (!(alg in algos)) {\n        throw new ExchangeError (alg + ' is not a supported rsa signing algorithm.')\n    }\n    const algorithm = algos[alg]\n    let key = new NodeRSA (secret, {\n        'environment': 'browser',\n        'signingScheme': algorithm,\n    })\n    return key.sign (request, 'base64', 'binary')\n}\n\n\n/**\n * @return {string}\n */\nfunction jwt (request, secret, alg = 'HS256') {\n    const algos = {\n        'HS256': 'sha256',\n        'HS384': 'sha384',\n        'HS512': 'sha512',\n    };\n    const encodedHeader = urlencodeBase64 (stringToBase64 (JSON.stringify ({ 'alg': alg, 'typ': 'JWT' })))\n    const encodedData = urlencodeBase64 (stringToBase64 (JSON.stringify (request)))\n    const token = [ encodedHeader, encodedData ].join ('.')\n    const algoType = alg.slice (0, 2);\n    const algorithm = algos[alg]\n    let signature = undefined\n    if (algoType === 'HS') {\n        signature = urlencodeBase64 (hmac (token, secret, algorithm, 'base64'))\n    } else if (algoType === 'RS') {\n        signature = urlencodeBase64 (rsa (token, secret, alg))\n    }\n    return [ token, signature ].join ('.')\n}\n\nfunction ecdsa (request, secret, algorithm = 'p256', hashFunction = undefined, fixedLength = false) {\n    let digest = request\n    if (hashFunction !== undefined) {\n        digest = hash (request, hashFunction, 'hex')\n    }\n    const curve = new EC (algorithm)\n    let signature = curve.sign (digest, secret, 'hex',  { 'canonical': true })\n    let counter = new BN ('0')\n    const minimum_size = new BN ('1').shln (8 * 31).sub (new BN ('1'))\n    while (fixedLength && (signature.r.gt (curve.nh) || signature.r.lte (minimum_size) || signature.s.lte (minimum_size))) {\n        signature = curve.sign (digest, secret, 'hex',  { 'canonical': true, 'extraEntropy': counter.toArray ('le', 32)})\n        counter = counter.add (new BN ('1'))\n    }\n    return {\n        'r': signature.r.toString (16).padStart (64, '0'),\n        's': signature.s.toString (16).padStart (64, '0'),\n        'v': signature.recoveryParam,\n    }\n}\n\n\nfunction eddsa (request, secret, algorithm = 'ed25519') {\n    // used for waves.exchange (that's why the output is base58)\n    const curve = new EDDSA (algorithm)\n    const signature = curve.signModified (request, secret)\n    return binaryToBase58 (byteArrayToWordArray (signature.toBytes ()))\n}\n\n/*  ------------------------------------------------------------------------ */\n\nconst totp = (secret) => {\n\n    const dec2hex = s => ((s < 15.5 ? '0' : '') + Math.round (s).toString (16))\n        , hex2dec = s => parseInt (s, 16)\n        , leftpad = (s, p) => (p + s).slice (-p.length) // both s and p are short strings\n\n    const base32tohex = (base32) => {\n        let base32chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n        let bits = ''\n        let hex = ''\n        for (let i = 0; i < base32.length; i++) {\n            let val = base32chars.indexOf (base32.charAt (i).toUpperCase ())\n            bits += leftpad (val.toString (2), '00000')\n        }\n        for (let i = 0; i + 4 <= bits.length; i += 4) {\n            let chunk = bits.substr (i, 4)\n            hex = hex + parseInt (chunk, 2).toString (16)\n        }\n        return hex\n    }\n\n    const getOTP = (secret) => {\n        secret = secret.replace (' ', '') // support 2fa-secrets with spaces like \"4TDV WOGO\" → \"4TDVWOGO\"\n        let epoch = Math.round (new Date ().getTime () / 1000.0)\n        let time = leftpad (dec2hex (Math.floor (epoch / 30)), '0000000000000000')\n        let hmacRes = hmac (CryptoJS.enc.Hex.parse (time), CryptoJS.enc.Hex.parse (base32tohex (secret)), 'sha1', 'hex')\n        let offset = hex2dec (hmacRes.substring (hmacRes.length - 1))\n        let otp = (hex2dec (hmacRes.substr (offset * 2, 8)) & hex2dec ('7fffffff')) + ''\n        otp = (otp).substr (otp.length - 6, 6)\n        return otp\n    }\n\n    return getOTP (secret)\n}\n\n/*  ------------------------------------------------------------------------ */\n\nmodule.exports = {\n    hash,\n    hmac,\n    jwt,\n    totp,\n    rsa,\n    ecdsa,\n    eddsa,\n}\n\n/*  ------------------------------------------------------------------------ */\n"]},"metadata":{},"sourceType":"script"}